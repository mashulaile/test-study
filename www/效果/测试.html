<!DOCTYPE html>
<html>

	<head>
		<meta charset="UTF-8">
		<title></title>
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
		<meta content="telephone=no" name="format-detection">
		<script>
        ! function () {
            var e = "@charset \"utf-8\";html{color:#000;background:#fff;overflow-y:scroll;-webkit-text-size-adjust:100%;-ms-text-size-adjust:100%}html *{outline:0;-webkit-text-size-adjust:none;-webkit-tap-highlight-color:rgba(0,0,0,0)}html,body{font-family:sans-serif}body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,textarea,p,blockquote,th,td,hr,button,article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section{margin:0;padding:0}input,select,textarea{font-size:100%}table{border-collapse:collapse;border-spacing:0}fieldset,img{border:0}abbr,acronym{border:0;font-variant:normal}del{text-decoration:line-through}address,caption,cite,code,dfn,em,th,var{font-style:normal;font-weight:500}ol,ul{list-style:none}caption,th{text-align:left}h1,h2,h3,h4,h5,h6{font-size:100%;font-weight:500}q:before,q:after{content:''}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-.5em}sub{bottom:-.25em}a:hover{text-decoration:underline}ins,a{text-decoration:none}",
                d = document.createElement("style");
            if (document.getElementsByTagName("head")[0].appendChild(d), d.styleSheet) {
                d.styleSheet.disabled || (d.styleSheet.cssText = e)
            } else {
                try {
                    d.innerHTML = e
                } catch (f) {
                    d.innerText = e
                }
            }
        }();

        ! function (N, M) {
            function L() {
                var a = I.getBoundingClientRect().width;
                a / F > 540 && (a = 540 * F);
                var d = a / 10;
                I.style.fontSize = d + "px", D.rem = N.rem = d
            }
            var K, J = N.document,
                I = J.documentElement,
                H = J.querySelector('meta[name="viewport"]'),
                G = J.querySelector('meta[name="flexible"]'),
                F = 0,
                E = 0,
                D = M.flexible || (M.flexible = {});
            if (H) {
                console.warn("将根据已有的meta标签来设置缩放比例");
                var C = H.getAttribute("content").match(/initial\-scale=([\d\.]+)/);
                C && (E = parseFloat(C[1]), F = parseInt(1 / E))
            } else {
                if (G) {
                    var B = G.getAttribute("content");
                    if (B) {
                        var A = B.match(/initial\-dpr=([\d\.]+)/),
                            z = B.match(/maximum\-dpr=([\d\.]+)/);
                        A && (F = parseFloat(A[1]), E = parseFloat((1 / F).toFixed(2))), z && (F = parseFloat(z[1]), E = parseFloat((1 / F).toFixed(2)))
                    }
                }
            }
            if (!F && !E) {
                var y = N.navigator.userAgent,
                    x = (!!y.match(/android/gi), !!y.match(/iphone/gi)),
                    w = x && !!y.match(/OS 9_3/),
                    v = N.devicePixelRatio;
                F = x && !w ? v >= 3 && (!F || F >= 3) ? 3 : v >= 2 && (!F || F >= 2) ? 2 : 1 : 1, E = 1 / F
            }
            if (I.setAttribute("data-dpr", F), !H) {
                if (H = J.createElement("meta"), H.setAttribute("name", "viewport"), H.setAttribute("content", "initial-scale=" + E + ", maximum-scale=" + E + ", minimum-scale=" + E + ", user-scalable=no"), I.firstElementChild) {
                    I.firstElementChild.appendChild(H)
                } else {
                    var u = J.createElement("div");
                    u.appendChild(H), J.write(u.innerHTML)
                }
            }
            N.addEventListener("resize", function () {
                clearTimeout(K), K = setTimeout(L, 300)
            }, !1), N.addEventListener("pageshow", function (b) {
                b.persisted && (clearTimeout(K), K = setTimeout(L, 300))
            }, !1), "complete" === J.readyState ? J.body.style.fontSize = 12 * F + "px" : J.addEventListener("DOMContentLoaded", function () {
                J.body.style.fontSize = 12 * F + "px"
            }, !1), L(), D.dpr = N.dpr = F, D.refreshRem = L, D.rem2px = function (d) {
                var c = parseFloat(d) * this.rem;
                return "string" == typeof d && d.match(/rem$/) && (c += "px"), c
            }, D.px2rem = function (d) {
                var c = parseFloat(d) / this.rem;
                return "string" == typeof d && d.match(/px$/) && (c += "rem"), c
            }
        }(window, window.lib || (window.lib = {}));
    </script>
		<style>
			*{padding: 0;margin: 0;}
			.man {
	    		/*display: none;
	    		opacity: 0;*/
    		}
    		.four {
    			width: 300px;
    			height: 300px;
    			/*background: url('https://gw.alicdn.com/tfs/TB1M6ThqgMPMeJjy1XbXXcwxVXa-320-401.png') no-repeat center center;
    			background-size: 100%;*/
    			font-size: 30px;
    			color: #000;
    		}
    		.four img {
    		    /*position:absolute;*/
    		    /*left:0;*/
    		    /*top:0;*/
    		    width:200px;
    		    height:200px;
    		   
    		}
		</style>
	</head>

	<body>
		<img  class="man" src="" />
		<div class="four" id="shareContent">
			这是HTML转换成图片
			<img src="data:image/png;base64,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" />
		</div>
		<!--<canvas id="canvas"></canvas>-->
		
		<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>    
        <!--<script src="js/haha.js"></script>-->
        <script>
        	/*
  html2canvas 0.5.0-beta3 <http://html2canvas.hertzen.com>
  Copyright (c) 2016 Niklas von Hertzen

  Released under  License
*/

!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.html2canvas=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
(function (global){
/*! http://mths.be/punycode v1.2.4 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports;
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^ -~]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /\x2E|\u3002|\uFF0E|\uFF61/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		while (length--) {
			array[length] = fn(array[length]);
		}
		return array;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings.
	 * @private
	 * @param {String} domain The domain name.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		return map(string.split(regexSeparators), fn).join('.');
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <http://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols to a Punycode string of ASCII-only
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name to Unicode. Only the
	 * Punycoded parts of the domain name will be converted, i.e. it doesn't
	 * matter if you call it on a string that has already been converted to
	 * Unicode.
	 * @memberOf punycode
	 * @param {String} domain The Punycode domain name to convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(domain) {
		return mapDomain(domain, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name to Punycode. Only the
	 * non-ASCII parts of the domain name will be converted, i.e. it doesn't
	 * matter if you call it with a domain that's already in ASCII.
	 * @memberOf punycode
	 * @param {String} domain The domain name to convert, as a Unicode string.
	 * @returns {String} The Punycode representation of the given domain name.
	 */
	function toASCII(domain) {
		return mapDomain(domain, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.2.4',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <http://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else { // in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],2:[function(_dereq_,module,exports){
var log = _dereq_('./log');

function restoreOwnerScroll(ownerDocument, x, y) {
    if (ownerDocument.defaultView && (x !== ownerDocument.defaultView.pageXOffset || y !== ownerDocument.defaultView.pageYOffset)) {
        ownerDocument.defaultView.scrollTo(x, y);
    }
}

function cloneCanvasContents(canvas, clonedCanvas) {
    try {
        if (clonedCanvas) {
            clonedCanvas.width = canvas.width;
            clonedCanvas.height = canvas.height;
            clonedCanvas.getContext("2d").putImageData(canvas.getContext("2d").getImageData(0, 0, canvas.width, canvas.height), 0, 0);
        }
    } catch(e) {
        log("Unable to copy canvas content from", canvas, e);
    }
}

function cloneNode(node, javascriptEnabled) {
    var clone = node.nodeType === 3 ? document.createTextNode(node.nodeValue) : node.cloneNode(false);

    var child = node.firstChild;
    while(child) {
        if (javascriptEnabled === true || child.nodeType !== 1 || child.nodeName !== 'SCRIPT') {
            clone.appendChild(cloneNode(child, javascriptEnabled));
        }
        child = child.nextSibling;
    }

    if (node.nodeType === 1) {
        clone._scrollTop = node.scrollTop;
        clone._scrollLeft = node.scrollLeft;
        if (node.nodeName === "CANVAS") {
            cloneCanvasContents(node, clone);
        } else if (node.nodeName === "TEXTAREA" || node.nodeName === "SELECT") {
            clone.value = node.value;
        }
    }

    return clone;
}

function initNode(node) {
    if (node.nodeType === 1) {
        node.scrollTop = node._scrollTop;
        node.scrollLeft = node._scrollLeft;

        var child = node.firstChild;
        while(child) {
            initNode(child);
            child = child.nextSibling;
        }
    }
}

module.exports = function(ownerDocument, containerDocument, width, height, options, x ,y) {
    var documentElement = cloneNode(ownerDocument.documentElement, options.javascriptEnabled);
    var container = containerDocument.createElement("iframe");

    container.className = "html2canvas-container";
    container.style.visibility = "hidden";
    container.style.position = "fixed";
    container.style.left = "-10000px";
    container.style.top = "0px";
    container.style.border = "0";
    container.width = width;
    container.height = height;
    container.scrolling = "no"; // ios won't scroll without it
    containerDocument.body.appendChild(container);

    return new Promise(function(resolve) {
        var documentClone = container.contentWindow.document;

        /* Chrome doesn't detect relative background-images assigned in inline <style> sheets when fetched through getComputedStyle
         if window url is about:blank, we can assign the url to current by writing onto the document
         */
        container.contentWindow.onload = container.onload = function() {
            var interval = setInterval(function() {
                if (documentClone.body.childNodes.length > 0) {
                    initNode(documentClone.documentElement);
                    clearInterval(interval);
                    if (options.type === "view") {
                        container.contentWindow.scrollTo(x, y);
                        if ((/(iPad|iPhone|iPod)/g).test(navigator.userAgent) && (container.contentWindow.scrollY !== y || container.contentWindow.scrollX !== x)) {
                            documentClone.documentElement.style.top = (-y) + "px";
                            documentClone.documentElement.style.left = (-x) + "px";
                            documentClone.documentElement.style.position = 'absolute';
                        }
                    }
                    resolve(container);
                }
            }, 50);
        };

        documentClone.open();
        documentClone.write("<!DOCTYPE html><html></html>");
        // Chrome scrolls the parent document for some reason after the write to the cloned window???
        restoreOwnerScroll(ownerDocument, x, y);
        documentClone.replaceChild(documentClone.adoptNode(documentElement), documentClone.documentElement);
        documentClone.close();
    });
};

},{"./log":13}],3:[function(_dereq_,module,exports){
// http://dev.w3.org/csswg/css-color/

function Color(value) {
    this.r = 0;
    this.g = 0;
    this.b = 0;
    this.a = null;
    var result = this.fromArray(value) ||
        this.namedColor(value) ||
        this.rgb(value) ||
        this.rgba(value) ||
        this.hex6(value) ||
        this.hex3(value);
}

Color.prototype.darken = function(amount) {
    var a = 1 - amount;
    return  new Color([
        Math.round(this.r * a),
        Math.round(this.g * a),
        Math.round(this.b * a),
        this.a
    ]);
};

Color.prototype.isTransparent = function() {
    return this.a === 0;
};

Color.prototype.isBlack = function() {
    return this.r === 0 && this.g === 0 && this.b === 0;
};

Color.prototype.fromArray = function(array) {
    if (Array.isArray(array)) {
        this.r = Math.min(array[0], 255);
        this.g = Math.min(array[1], 255);
        this.b = Math.min(array[2], 255);
        if (array.length > 3) {
            this.a = array[3];
        }
    }

    return (Array.isArray(array));
};

var _hex3 = /^#([a-f0-9]{3})$/i;

Color.prototype.hex3 = function(value) {
    var match = null;
    if ((match = value.match(_hex3)) !== null) {
        this.r = parseInt(match[1][0] + match[1][0], 16);
        this.g = parseInt(match[1][1] + match[1][1], 16);
        this.b = parseInt(match[1][2] + match[1][2], 16);
    }
    return match !== null;
};

var _hex6 = /^#([a-f0-9]{6})$/i;

Color.prototype.hex6 = function(value) {
    var match = null;
    if ((match = value.match(_hex6)) !== null) {
        this.r = parseInt(match[1].substring(0, 2), 16);
        this.g = parseInt(match[1].substring(2, 4), 16);
        this.b = parseInt(match[1].substring(4, 6), 16);
    }
    return match !== null;
};


var _rgb = /^rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)$/;

Color.prototype.rgb = function(value) {
    var match = null;
    if ((match = value.match(_rgb)) !== null) {
        this.r = Number(match[1]);
        this.g = Number(match[2]);
        this.b = Number(match[3]);
    }
    return match !== null;
};

var _rgba = /^rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d?\.?\d+)\s*\)$/;

Color.prototype.rgba = function(value) {
    var match = null;
    if ((match = value.match(_rgba)) !== null) {
        this.r = Number(match[1]);
        this.g = Number(match[2]);
        this.b = Number(match[3]);
        this.a = Number(match[4]);
    }
    return match !== null;
};

Color.prototype.toString = function() {
    return this.a !== null && this.a !== 1 ?
    "rgba(" + [this.r, this.g, this.b, this.a].join(",") + ")" :
    "rgb(" + [this.r, this.g, this.b].join(",") + ")";
};

Color.prototype.namedColor = function(value) {
    value = value.toLowerCase();
    var color = colors[value];
    if (color) {
        this.r = color[0];
        this.g = color[1];
        this.b = color[2];
    } else if (value === "transparent") {
        this.r = this.g = this.b = this.a = 0;
        return true;
    }

    return !!color;
};

Color.prototype.isColor = true;

// JSON.stringify([].slice.call($$('.named-color-table tr'), 1).map(function(row) { return [row.childNodes[3].textContent, row.childNodes[5].textContent.trim().split(",").map(Number)] }).reduce(function(data, row) {data[row[0]] = row[1]; return data}, {}))
var colors = {
    "aliceblue": [240, 248, 255],
    "antiquewhite": [250, 235, 215],
    "aqua": [0, 255, 255],
    "aquamarine": [127, 255, 212],
    "azure": [240, 255, 255],
    "beige": [245, 245, 220],
    "bisque": [255, 228, 196],
    "black": [0, 0, 0],
    "blanchedalmond": [255, 235, 205],
    "blue": [0, 0, 255],
    "blueviolet": [138, 43, 226],
    "brown": [165, 42, 42],
    "burlywood": [222, 184, 135],
    "cadetblue": [95, 158, 160],
    "chartreuse": [127, 255, 0],
    "chocolate": [210, 105, 30],
    "coral": [255, 127, 80],
    "cornflowerblue": [100, 149, 237],
    "cornsilk": [255, 248, 220],
    "crimson": [220, 20, 60],
    "cyan": [0, 255, 255],
    "darkblue": [0, 0, 139],
    "darkcyan": [0, 139, 139],
    "darkgoldenrod": [184, 134, 11],
    "darkgray": [169, 169, 169],
    "darkgreen": [0, 100, 0],
    "darkgrey": [169, 169, 169],
    "darkkhaki": [189, 183, 107],
    "darkmagenta": [139, 0, 139],
    "darkolivegreen": [85, 107, 47],
    "darkorange": [255, 140, 0],
    "darkorchid": [153, 50, 204],
    "darkred": [139, 0, 0],
    "darksalmon": [233, 150, 122],
    "darkseagreen": [143, 188, 143],
    "darkslateblue": [72, 61, 139],
    "darkslategray": [47, 79, 79],
    "darkslategrey": [47, 79, 79],
    "darkturquoise": [0, 206, 209],
    "darkviolet": [148, 0, 211],
    "deeppink": [255, 20, 147],
    "deepskyblue": [0, 191, 255],
    "dimgray": [105, 105, 105],
    "dimgrey": [105, 105, 105],
    "dodgerblue": [30, 144, 255],
    "firebrick": [178, 34, 34],
    "floralwhite": [255, 250, 240],
    "forestgreen": [34, 139, 34],
    "fuchsia": [255, 0, 255],
    "gainsboro": [220, 220, 220],
    "ghostwhite": [248, 248, 255],
    "gold": [255, 215, 0],
    "goldenrod": [218, 165, 32],
    "gray": [128, 128, 128],
    "green": [0, 128, 0],
    "greenyellow": [173, 255, 47],
    "grey": [128, 128, 128],
    "honeydew": [240, 255, 240],
    "hotpink": [255, 105, 180],
    "indianred": [205, 92, 92],
    "indigo": [75, 0, 130],
    "ivory": [255, 255, 240],
    "khaki": [240, 230, 140],
    "lavender": [230, 230, 250],
    "lavenderblush": [255, 240, 245],
    "lawngreen": [124, 252, 0],
    "lemonchiffon": [255, 250, 205],
    "lightblue": [173, 216, 230],
    "lightcoral": [240, 128, 128],
    "lightcyan": [224, 255, 255],
    "lightgoldenrodyellow": [250, 250, 210],
    "lightgray": [211, 211, 211],
    "lightgreen": [144, 238, 144],
    "lightgrey": [211, 211, 211],
    "lightpink": [255, 182, 193],
    "lightsalmon": [255, 160, 122],
    "lightseagreen": [32, 178, 170],
    "lightskyblue": [135, 206, 250],
    "lightslategray": [119, 136, 153],
    "lightslategrey": [119, 136, 153],
    "lightsteelblue": [176, 196, 222],
    "lightyellow": [255, 255, 224],
    "lime": [0, 255, 0],
    "limegreen": [50, 205, 50],
    "linen": [250, 240, 230],
    "magenta": [255, 0, 255],
    "maroon": [128, 0, 0],
    "mediumaquamarine": [102, 205, 170],
    "mediumblue": [0, 0, 205],
    "mediumorchid": [186, 85, 211],
    "mediumpurple": [147, 112, 219],
    "mediumseagreen": [60, 179, 113],
    "mediumslateblue": [123, 104, 238],
    "mediumspringgreen": [0, 250, 154],
    "mediumturquoise": [72, 209, 204],
    "mediumvioletred": [199, 21, 133],
    "midnightblue": [25, 25, 112],
    "mintcream": [245, 255, 250],
    "mistyrose": [255, 228, 225],
    "moccasin": [255, 228, 181],
    "navajowhite": [255, 222, 173],
    "navy": [0, 0, 128],
    "oldlace": [253, 245, 230],
    "olive": [128, 128, 0],
    "olivedrab": [107, 142, 35],
    "orange": [255, 165, 0],
    "orangered": [255, 69, 0],
    "orchid": [218, 112, 214],
    "palegoldenrod": [238, 232, 170],
    "palegreen": [152, 251, 152],
    "paleturquoise": [175, 238, 238],
    "palevioletred": [219, 112, 147],
    "papayawhip": [255, 239, 213],
    "peachpuff": [255, 218, 185],
    "peru": [205, 133, 63],
    "pink": [255, 192, 203],
    "plum": [221, 160, 221],
    "powderblue": [176, 224, 230],
    "purple": [128, 0, 128],
    "rebeccapurple": [102, 51, 153],
    "red": [255, 0, 0],
    "rosybrown": [188, 143, 143],
    "royalblue": [65, 105, 225],
    "saddlebrown": [139, 69, 19],
    "salmon": [250, 128, 114],
    "sandybrown": [244, 164, 96],
    "seagreen": [46, 139, 87],
    "seashell": [255, 245, 238],
    "sienna": [160, 82, 45],
    "silver": [192, 192, 192],
    "skyblue": [135, 206, 235],
    "slateblue": [106, 90, 205],
    "slategray": [112, 128, 144],
    "slategrey": [112, 128, 144],
    "snow": [255, 250, 250],
    "springgreen": [0, 255, 127],
    "steelblue": [70, 130, 180],
    "tan": [210, 180, 140],
    "teal": [0, 128, 128],
    "thistle": [216, 191, 216],
    "tomato": [255, 99, 71],
    "turquoise": [64, 224, 208],
    "violet": [238, 130, 238],
    "wheat": [245, 222, 179],
    "white": [255, 255, 255],
    "whitesmoke": [245, 245, 245],
    "yellow": [255, 255, 0],
    "yellowgreen": [154, 205, 50]
};

module.exports = Color;

},{}],4:[function(_dereq_,module,exports){
var Support = _dereq_('./support');
var CanvasRenderer = _dereq_('./renderers/canvas');
var ImageLoader = _dereq_('./imageloader');
var NodeParser = _dereq_('./nodeparser');
var NodeContainer = _dereq_('./nodecontainer');
var log = _dereq_('./log');
var utils = _dereq_('./utils');
var createWindowClone = _dereq_('./clone');
var loadUrlDocument = _dereq_('./proxy').loadUrlDocument;
var getBounds = utils.getBounds;

var html2canvasNodeAttribute = "data-html2canvas-node";
var html2canvasCloneIndex = 0;

function html2canvas(nodeList, options) {
    var index = html2canvasCloneIndex++;
    options = options || {};
    if (options.logging) {
        log.options.logging = true;
        log.options.start = Date.now();
    }

    options.async = typeof(options.async) === "undefined" ? true : options.async;
    options.allowTaint = typeof(options.allowTaint) === "undefined" ? false : options.allowTaint;
    options.removeContainer = typeof(options.removeContainer) === "undefined" ? true : options.removeContainer;
    options.javascriptEnabled = typeof(options.javascriptEnabled) === "undefined" ? false : options.javascriptEnabled;
    options.imageTimeout = typeof(options.imageTimeout) === "undefined" ? 10000 : options.imageTimeout;
    options.renderer = typeof(options.renderer) === "function" ? options.renderer : CanvasRenderer;
    options.strict = !!options.strict;

    if (typeof(nodeList) === "string") {
        if (typeof(options.proxy) !== "string") {
            return Promise.reject("Proxy must be used when rendering url");
        }
        var width = options.width != null ? options.width : window.innerWidth;
        var height = options.height != null ? options.height : window.innerHeight;
        return loadUrlDocument(absoluteUrl(nodeList), options.proxy, document, width, height, options).then(function(container) {
            return renderWindow(container.contentWindow.document.documentElement, container, options, width, height);
        });
    }

    var node = ((nodeList === undefined) ? [document.documentElement] : ((nodeList.length) ? nodeList : [nodeList]))[0];
    node.setAttribute(html2canvasNodeAttribute + index, index);
    width = options.width != null ? options.width : node.ownerDocument.defaultView.innerWidth;
height = options.height != null ? options.height : node.ownerDocument.defaultView.innerHeight;
return renderDocument(node.ownerDocument, options, width, height, index).then(function(canvas) {
    if (typeof(options.onrendered) === "function") {
        log("options.onrendered is deprecated, html2canvas returns a Promise containing the canvas");
        options.onrendered(canvas);
    }
    return canvas;
});
}

html2canvas.CanvasRenderer = CanvasRenderer;
html2canvas.NodeContainer = NodeContainer;
html2canvas.log = log;
html2canvas.utils = utils;

var html2canvasExport = (typeof(document) === "undefined" || typeof(Object.create) !== "function" || typeof(document.createElement("canvas").getContext) !== "function") ? function() {
    return Promise.reject("No canvas support");
} : html2canvas;

module.exports = html2canvasExport;

if (typeof(define) === 'function' && define.amd) {
    define('html2canvas', [], function() {
        return html2canvasExport;
    });
}

function renderDocument(document, options, windowWidth, windowHeight, html2canvasIndex) {
    return createWindowClone(document, document, windowWidth, windowHeight, options, document.defaultView.pageXOffset, document.defaultView.pageYOffset).then(function(container) {
        log("Document cloned");
        var attributeName = html2canvasNodeAttribute + html2canvasIndex;
        var selector = "[" + attributeName + "='" + html2canvasIndex + "']";
        document.querySelector(selector).removeAttribute(attributeName);
        var clonedWindow = container.contentWindow;
        var node = clonedWindow.document.querySelector(selector);
        var oncloneHandler = (typeof(options.onclone) === "function") ? Promise.resolve(options.onclone(clonedWindow.document)) : Promise.resolve(true);
        return oncloneHandler.then(function() {
            return renderWindow(node, container, options, windowWidth, windowHeight);
        });
    });
}

function renderWindow(node, container, options, windowWidth, windowHeight) {
    var clonedWindow = container.contentWindow;
    var support = new Support(clonedWindow.document);
    var imageLoader = new ImageLoader(options, support);
    var bounds = getBounds(node);
    var width = options.type === "view" ? windowWidth : documentWidth(clonedWindow.document);
    var height = options.type === "view" ? windowHeight : documentHeight(clonedWindow.document);
    var renderer = new options.renderer(width, height, imageLoader, options, document);
    var parser = new NodeParser(node, renderer, support, imageLoader, options);
    return parser.ready.then(function() {
        log("Finished rendering");
        var canvas;

        if (options.type === "view") {
                canvas = crop(renderer.canvas, {width: renderer.canvas.width, height: renderer.canvas.height, top: 0, left: 0, x: 0, y: 0});
            } else if (node === clonedWindow.document.body || node === clonedWindow.document.documentElement) {
                canvas = renderer.canvas;
            }else if(options.scale && options.canvas !=null){
                log("放大canvas",options.canvas);
                var scale = options.scale || 1;
                canvas = crop(renderer.canvas, {width: bounds.width * scale, height:bounds.height * scale, top: bounds.top *scale, left: bounds.left *scale, x: 0, y: 0});
            }
            else {
                canvas = crop(renderer.canvas, {width:  options.width != null ? options.width : bounds.width, height: options.height != null ? options.height : bounds.height, top: bounds.top, left: bounds.left, x: 0, y: 0});
            }

        cleanupContainer(container, options);
        return canvas;
    });
}

function cleanupContainer(container, options) {
    if (options.removeContainer) {
        container.parentNode.removeChild(container);
        log("Cleaned up container");
    }
}

function crop(canvas, bounds) {
    var croppedCanvas = document.createElement("canvas");
    var x1 = Math.min(canvas.width - 1, Math.max(0, bounds.left));
    var x2 = Math.min(canvas.width, Math.max(1, bounds.left + bounds.width));
    var y1 = Math.min(canvas.height - 1, Math.max(0, bounds.top));
    var y2 = Math.min(canvas.height, Math.max(1, bounds.top + bounds.height));
    croppedCanvas.width = bounds.width;
    croppedCanvas.height =  bounds.height;
    var width = x2-x1;
    var height = y2-y1;
    log("Cropping canvas at:", "left:", bounds.left, "top:", bounds.top, "width:", width, "height:", height);
    log("Resulting crop with width", bounds.width, "and height", bounds.height, "with x", x1, "and y", y1);
    croppedCanvas.getContext("2d").drawImage(canvas, x1, y1, width, height, bounds.x, bounds.y, width, height);
    return croppedCanvas;
}

function documentWidth (doc) {
    return Math.max(
        Math.max(doc.body.scrollWidth, doc.documentElement.scrollWidth),
        Math.max(doc.body.offsetWidth, doc.documentElement.offsetWidth),
        Math.max(doc.body.clientWidth, doc.documentElement.clientWidth)
    );
}

function documentHeight (doc) {
    return Math.max(
        Math.max(doc.body.scrollHeight, doc.documentElement.scrollHeight),
        Math.max(doc.body.offsetHeight, doc.documentElement.offsetHeight),
        Math.max(doc.body.clientHeight, doc.documentElement.clientHeight)
    );
}

function absoluteUrl(url) {
    var link = document.createElement("a");
    link.href = url;
    link.href = link.href;
    return link;
}

},{"./clone":2,"./imageloader":11,"./log":13,"./nodecontainer":14,"./nodeparser":15,"./proxy":16,"./renderers/canvas":20,"./support":22,"./utils":26}],5:[function(_dereq_,module,exports){
var log = _dereq_('./log');
var smallImage = _dereq_('./utils').smallImage;

function DummyImageContainer(src) {
    this.src = src;
    log("DummyImageContainer for", src);
    if (!this.promise || !this.image) {
        log("Initiating DummyImageContainer");
        DummyImageContainer.prototype.image = new Image();
        var image = this.image;
        DummyImageContainer.prototype.promise = new Promise(function(resolve, reject) {
            image.onload = resolve;
            image.onerror = reject;
            image.src = smallImage();
            if (image.complete === true) {
                resolve(image);
            }
        });
    }
}

module.exports = DummyImageContainer;

},{"./log":13,"./utils":26}],6:[function(_dereq_,module,exports){
var smallImage = _dereq_('./utils').smallImage;

function Font(family, size) {
    var container = document.createElement('div'),
        img = document.createElement('img'),
        span = document.createElement('span'),
        sampleText = 'Hidden Text',
        baseline,
        middle;

    container.style.visibility = "hidden";
    container.style.fontFamily = family;
    container.style.fontSize = size;
    container.style.margin = 0;
    container.style.padding = 0;

    document.body.appendChild(container);

    img.src = smallImage();
    img.width = 1;
    img.height = 1;

    img.style.margin = 0;
    img.style.padding = 0;
    img.style.verticalAlign = "baseline";

    span.style.fontFamily = family;
    span.style.fontSize = size;
    span.style.margin = 0;
    span.style.padding = 0;

    span.appendChild(document.createTextNode(sampleText));
    container.appendChild(span);
    container.appendChild(img);
    baseline = (img.offsetTop - span.offsetTop) + 1;

    container.removeChild(span);
    container.appendChild(document.createTextNode(sampleText));

    container.style.lineHeight = "normal";
    img.style.verticalAlign = "super";

    middle = (img.offsetTop-container.offsetTop) + 1;

    document.body.removeChild(container);

    this.baseline = baseline;
    this.lineWidth = 1;
    this.middle = middle;
}

module.exports = Font;

},{"./utils":26}],7:[function(_dereq_,module,exports){
var Font = _dereq_('./font');

function FontMetrics() {
    this.data = {};
}

FontMetrics.prototype.getMetrics = function(family, size) {
    if (this.data[family + "-" + size] === undefined) {
        this.data[family + "-" + size] = new Font(family, size);
    }
    return this.data[family + "-" + size];
};

module.exports = FontMetrics;

},{"./font":6}],8:[function(_dereq_,module,exports){
var utils = _dereq_('./utils');
var getBounds = utils.getBounds;
var loadUrlDocument = _dereq_('./proxy').loadUrlDocument;

function FrameContainer(container, sameOrigin, options) {
    this.image = null;
    this.src = container;
    var self = this;
    var bounds = getBounds(container);
    this.promise = (!sameOrigin ? this.proxyLoad(options.proxy, bounds, options) : new Promise(function(resolve) {
        if (container.contentWindow.document.URL === "about:blank" || container.contentWindow.document.documentElement == null) {
            container.contentWindow.onload = container.onload = function() {
                resolve(container);
            };
        } else {
            resolve(container);
        }
    })).then(function(container) {
        var html2canvas = _dereq_('./core');
        return html2canvas(container.contentWindow.document.documentElement, {type: 'view', width: container.width, height: container.height, proxy: options.proxy, javascriptEnabled: options.javascriptEnabled, removeContainer: options.removeContainer, allowTaint: options.allowTaint, imageTimeout: options.imageTimeout / 2});
    }).then(function(canvas) {
        return self.image = canvas;
    });
}

FrameContainer.prototype.proxyLoad = function(proxy, bounds, options) {
    var container = this.src;
    return loadUrlDocument(container.src, proxy, container.ownerDocument, bounds.width, bounds.height, options);
};

module.exports = FrameContainer;

},{"./core":4,"./proxy":16,"./utils":26}],9:[function(_dereq_,module,exports){
function GradientContainer(imageData) {
    this.src = imageData.value;
    this.colorStops = [];
    this.type = null;
    this.x0 = 0.5;
    this.y0 = 0.5;
    this.x1 = 0.5;
    this.y1 = 0.5;
    this.promise = Promise.resolve(true);
}

GradientContainer.TYPES = {
    LINEAR: 1,
    RADIAL: 2
};

// TODO: support hsl[a], negative %/length values
// TODO: support <angle> (e.g. -?\d{1,3}(?:\.\d+)deg, etc. : https://developer.mozilla.org/docs/Web/CSS/angle )
GradientContainer.REGEXP_COLORSTOP = /^\s*(rgba?\(\s*\d{1,3},\s*\d{1,3},\s*\d{1,3}(?:,\s*[0-9\.]+)?\s*\)|[a-z]{3,20}|#[a-f0-9]{3,6})(?:\s+(\d{1,3}(?:\.\d+)?)(%|px)?)?(?:\s|$)/i;

module.exports = GradientContainer;

},{}],10:[function(_dereq_,module,exports){
function ImageContainer(src, cors) {
    this.src = src;
    this.image = new Image();
    var self = this;
    this.tainted = null;
    this.promise = new Promise(function(resolve, reject) {
        self.image.onload = resolve;
        self.image.onerror = reject;
        if (cors) {
            self.image.crossOrigin = "anonymous";
        }
        self.image.src = src;
        if (self.image.complete === true) {
            resolve(self.image);
        }
    });
}

module.exports = ImageContainer;

},{}],11:[function(_dereq_,module,exports){
var log = _dereq_('./log');
var ImageContainer = _dereq_('./imagecontainer');
var DummyImageContainer = _dereq_('./dummyimagecontainer');
var ProxyImageContainer = _dereq_('./proxyimagecontainer');
var FrameContainer = _dereq_('./framecontainer');
var SVGContainer = _dereq_('./svgcontainer');
var SVGNodeContainer = _dereq_('./svgnodecontainer');
var LinearGradientContainer = _dereq_('./lineargradientcontainer');
var WebkitGradientContainer = _dereq_('./webkitgradientcontainer');
var bind = _dereq_('./utils').bind;

function ImageLoader(options, support) {
    this.link = null;
    this.options = options;
    this.support = support;
    this.origin = this.getOrigin(window.location.href);
}

ImageLoader.prototype.findImages = function(nodes) {
    var images = [];
    nodes.reduce(function(imageNodes, container) {
        switch(container.node.nodeName) {
        case "IMG":
            return imageNodes.concat([{
                args: [container.node.src],
                method: "url"
            }]);
        case "svg":
        case "IFRAME":
            return imageNodes.concat([{
                args: [container.node],
                method: container.node.nodeName
            }]);
        }
        return imageNodes;
    }, []).forEach(this.addImage(images, this.loadImage), this);
    return images;
};

ImageLoader.prototype.findBackgroundImage = function(images, container) {
    container.parseBackgroundImages().filter(this.hasImageBackground).forEach(this.addImage(images, this.loadImage), this);
    return images;
};

ImageLoader.prototype.addImage = function(images, callback) {
    return function(newImage) {
        newImage.args.forEach(function(image) {
            if (!this.imageExists(images, image)) {
                images.splice(0, 0, callback.call(this, newImage));
                log('Added image #' + (images.length), typeof(image) === "string" ? image.substring(0, 100) : image);
            }
        }, this);
    };
};

ImageLoader.prototype.hasImageBackground = function(imageData) {
    return imageData.method !== "none";
};

ImageLoader.prototype.loadImage = function(imageData) {
    if (imageData.method === "url") {
        var src = imageData.args[0];
        if (this.isSVG(src) && !this.support.svg && !this.options.allowTaint) {
            return new SVGContainer(src);
        } else if (src.match(/data:image\/.*;base64,/i)) {
            return new ImageContainer(src.replace(/url\(['"]{0,}|['"]{0,}\)$/ig, ''), false);
        } else if (this.isSameOrigin(src) || this.options.allowTaint === true || this.isSVG(src)) {
            return new ImageContainer(src, false);
        } else if (this.support.cors && !this.options.allowTaint && this.options.useCORS) {
            return new ImageContainer(src, true);
        } else if (this.options.proxy) {
            return new ProxyImageContainer(src, this.options.proxy);
        } else {
            return new DummyImageContainer(src);
        }
    } else if (imageData.method === "linear-gradient") {
        return new LinearGradientContainer(imageData);
    } else if (imageData.method === "gradient") {
        return new WebkitGradientContainer(imageData);
    } else if (imageData.method === "svg") {
        return new SVGNodeContainer(imageData.args[0], this.support.svg);
    } else if (imageData.method === "IFRAME") {
        return new FrameContainer(imageData.args[0], this.isSameOrigin(imageData.args[0].src), this.options);
    } else {
        return new DummyImageContainer(imageData);
    }
};

ImageLoader.prototype.isSVG = function(src) {
    return src.substring(src.length - 3).toLowerCase() === "svg" || SVGContainer.prototype.isInline(src);
};

ImageLoader.prototype.imageExists = function(images, src) {
    return images.some(function(image) {
        return image.src === src;
    });
};

ImageLoader.prototype.isSameOrigin = function(url) {
    return (this.getOrigin(url) === this.origin);
};

ImageLoader.prototype.getOrigin = function(url) {
    var link = this.link || (this.link = document.createElement("a"));
    link.href = url;
    link.href = link.href; // IE9, LOL! - http://jsfiddle.net/niklasvh/2e48b/
    return link.protocol + link.hostname + link.port;
};

ImageLoader.prototype.getPromise = function(container) {
    return this.timeout(container, this.options.imageTimeout)['catch'](function() {
        var dummy = new DummyImageContainer(container.src);
        return dummy.promise.then(function(image) {
            container.image = image;
        });
    });
};

ImageLoader.prototype.get = function(src) {
    var found = null;
    return this.images.some(function(img) {
        return (found = img).src === src;
    }) ? found : null;
};

ImageLoader.prototype.fetch = function(nodes) {
    this.images = nodes.reduce(bind(this.findBackgroundImage, this), this.findImages(nodes));
    this.images.forEach(function(image, index) {
        image.promise.then(function() {
            log("Succesfully loaded image #"+ (index+1), image);
        }, function(e) {
            log("Failed loading image #"+ (index+1), image, e);
        });
    });
    this.ready = Promise.all(this.images.map(this.getPromise, this));
    log("Finished searching images");
    return this;
};

ImageLoader.prototype.timeout = function(container, timeout) {
    var timer;
    var promise = Promise.race([container.promise, new Promise(function(res, reject) {
        timer = setTimeout(function() {
            log("Timed out loading image", container);
            reject(container);
        }, timeout);
    })]).then(function(container) {
        clearTimeout(timer);
        return container;
    });
    promise['catch'](function() {
        clearTimeout(timer);
    });
    return promise;
};

module.exports = ImageLoader;

},{"./dummyimagecontainer":5,"./framecontainer":8,"./imagecontainer":10,"./lineargradientcontainer":12,"./log":13,"./proxyimagecontainer":17,"./svgcontainer":23,"./svgnodecontainer":24,"./utils":26,"./webkitgradientcontainer":27}],12:[function(_dereq_,module,exports){
var GradientContainer = _dereq_('./gradientcontainer');
var Color = _dereq_('./color');

function LinearGradientContainer(imageData) {
    GradientContainer.apply(this, arguments);
    this.type = GradientContainer.TYPES.LINEAR;

    var hasDirection = LinearGradientContainer.REGEXP_DIRECTION.test( imageData.args[0] ) ||
        !GradientContainer.REGEXP_COLORSTOP.test( imageData.args[0] );

    if (hasDirection) {
        imageData.args[0].split(/\s+/).reverse().forEach(function(position, index) {
            switch(position) {
            case "left":
                this.x0 = 0;
                this.x1 = 1;
                break;
            case "top":
                this.y0 = 0;
                this.y1 = 1;
                break;
            case "right":
                this.x0 = 1;
                this.x1 = 0;
                break;
            case "bottom":
                this.y0 = 1;
                this.y1 = 0;
                break;
            case "to":
                var y0 = this.y0;
                var x0 = this.x0;
                this.y0 = this.y1;
                this.x0 = this.x1;
                this.x1 = x0;
                this.y1 = y0;
                break;
            case "center":
                break; // centered by default
            // Firefox internally converts position keywords to percentages:
            // http://www.w3.org/TR/2010/WD-CSS2-20101207/colors.html#propdef-background-position
            default: // percentage or absolute length
                // TODO: support absolute start point positions (e.g., use bounds to convert px to a ratio)
                var ratio = parseFloat(position, 10) * 1e-2;
                if (isNaN(ratio)) { // invalid or unhandled value
                    break;
                }
                if (index === 0) {
                    this.y0 = ratio;
                    this.y1 = 1 - this.y0;
                } else {
                    this.x0 = ratio;
                    this.x1 = 1 - this.x0;
                }
                break;
            }
        }, this);
    } else {
        this.y0 = 0;
        this.y1 = 1;
    }

    this.colorStops = imageData.args.slice(hasDirection ? 1 : 0).map(function(colorStop) {
        var colorStopMatch = colorStop.match(GradientContainer.REGEXP_COLORSTOP);
        var value = +colorStopMatch[2];
        var unit = value === 0 ? "%" : colorStopMatch[3]; // treat "0" as "0%"
        return {
            color: new Color(colorStopMatch[1]),
            // TODO: support absolute stop positions (e.g., compute gradient line length & convert px to ratio)
            stop: unit === "%" ? value / 100 : null
        };
    });

    if (this.colorStops[0].stop === null) {
        this.colorStops[0].stop = 0;
    }

    if (this.colorStops[this.colorStops.length - 1].stop === null) {
        this.colorStops[this.colorStops.length - 1].stop = 1;
    }

    // calculates and fills-in explicit stop positions when omitted from rule
    this.colorStops.forEach(function(colorStop, index) {
        if (colorStop.stop === null) {
            this.colorStops.slice(index).some(function(find, count) {
                if (find.stop !== null) {
                    colorStop.stop = ((find.stop - this.colorStops[index - 1].stop) / (count + 1)) + this.colorStops[index - 1].stop;
                    return true;
                } else {
                    return false;
                }
            }, this);
        }
    }, this);
}

LinearGradientContainer.prototype = Object.create(GradientContainer.prototype);

// TODO: support <angle> (e.g. -?\d{1,3}(?:\.\d+)deg, etc. : https://developer.mozilla.org/docs/Web/CSS/angle )
LinearGradientContainer.REGEXP_DIRECTION = /^\s*(?:to|left|right|top|bottom|center|\d{1,3}(?:\.\d+)?%?)(?:\s|$)/i;

module.exports = LinearGradientContainer;

},{"./color":3,"./gradientcontainer":9}],13:[function(_dereq_,module,exports){
var logger = function() {
    if (logger.options.logging && window.console && window.console.log) {
        Function.prototype.bind.call(window.console.log, (window.console)).apply(window.console, [(Date.now() - logger.options.start) + "ms", "html2canvas:"].concat([].slice.call(arguments, 0)));
    }
};

logger.options = {logging: false};
module.exports = logger;

},{}],14:[function(_dereq_,module,exports){
var Color = _dereq_('./color');
var utils = _dereq_('./utils');
var getBounds = utils.getBounds;
var parseBackgrounds = utils.parseBackgrounds;
var offsetBounds = utils.offsetBounds;

function NodeContainer(node, parent) {
    this.node = node;
    this.parent = parent;
    this.stack = null;
    this.bounds = null;
    this.borders = null;
    this.clip = [];
    this.backgroundClip = [];
    this.offsetBounds = null;
    this.visible = null;
    this.computedStyles = null;
    this.colors = {};
    this.styles = {};
    this.backgroundImages = null;
    this.transformData = null;
    this.transformMatrix = null;
    this.isPseudoElement = false;
    this.opacity = null;
}

NodeContainer.prototype.cloneTo = function(stack) {
    stack.visible = this.visible;
    stack.borders = this.borders;
    stack.bounds = this.bounds;
    stack.clip = this.clip;
    stack.backgroundClip = this.backgroundClip;
    stack.computedStyles = this.computedStyles;
    stack.styles = this.styles;
    stack.backgroundImages = this.backgroundImages;
    stack.opacity = this.opacity;
};

NodeContainer.prototype.getOpacity = function() {
    return this.opacity === null ? (this.opacity = this.cssFloat('opacity')) : this.opacity;
};

NodeContainer.prototype.assignStack = function(stack) {
    this.stack = stack;
    stack.children.push(this);
};

NodeContainer.prototype.isElementVisible = function() {
    return this.node.nodeType === Node.TEXT_NODE ? this.parent.visible : (
        this.css('display') !== "none" &&
        this.css('visibility') !== "hidden" &&
        !this.node.hasAttribute("data-html2canvas-ignore") &&
        (this.node.nodeName !== "INPUT" || this.node.getAttribute("type") !== "hidden")
    );
};

NodeContainer.prototype.css = function(attribute) {
    if (!this.computedStyles) {
        this.computedStyles = this.isPseudoElement ? this.parent.computedStyle(this.before ? ":before" : ":after") : this.computedStyle(null);
    }

    return this.styles[attribute] || (this.styles[attribute] = this.computedStyles[attribute]);
};

NodeContainer.prototype.prefixedCss = function(attribute) {
    var prefixes = ["webkit", "moz", "ms", "o"];
    var value = this.css(attribute);
    if (value === undefined) {
        prefixes.some(function(prefix) {
            value = this.css(prefix + attribute.substr(0, 1).toUpperCase() + attribute.substr(1));
            return value !== undefined;
        }, this);
    }
    return value === undefined ? null : value;
};

NodeContainer.prototype.computedStyle = function(type) {
    return this.node.ownerDocument.defaultView.getComputedStyle(this.node, type);
};

NodeContainer.prototype.cssInt = function(attribute) {
    var value = parseInt(this.css(attribute), 10);
    return (isNaN(value)) ? 0 : value; // borders in old IE are throwing 'medium' for demo.html
};

NodeContainer.prototype.color = function(attribute) {
    return this.colors[attribute] || (this.colors[attribute] = new Color(this.css(attribute)));
};

NodeContainer.prototype.cssFloat = function(attribute) {
    var value = parseFloat(this.css(attribute));
    return (isNaN(value)) ? 0 : value;
};

NodeContainer.prototype.fontWeight = function() {
    var weight = this.css("fontWeight");
    switch(parseInt(weight, 10)){
    case 401:
        weight = "bold";
        break;
    case 400:
        weight = "normal";
        break;
    }
    return weight;
};

NodeContainer.prototype.parseClip = function() {
    var matches = this.css('clip').match(this.CLIP);
    if (matches) {
        return {
            top: parseInt(matches[1], 10),
            right: parseInt(matches[2], 10),
            bottom: parseInt(matches[3], 10),
            left: parseInt(matches[4], 10)
        };
    }
    return null;
};

NodeContainer.prototype.parseBackgroundImages = function() {
    return this.backgroundImages || (this.backgroundImages = parseBackgrounds(this.css("backgroundImage")));
};

NodeContainer.prototype.cssList = function(property, index) {
    var value = (this.css(property) || '').split(',');
    value = value[index || 0] || value[0] || 'auto';
    value = value.trim().split(' ');
    if (value.length === 1) {
        value = [value[0], isPercentage(value[0]) ? 'auto' : value[0]];
    }
    return value;
};

NodeContainer.prototype.parseBackgroundSize = function(bounds, image, index) {
    var size = this.cssList("backgroundSize", index);
    var width, height;

    if (isPercentage(size[0])) {
        width = bounds.width * parseFloat(size[0]) / 100;
    } else if (/contain|cover/.test(size[0])) {
        var targetRatio = bounds.width / bounds.height, currentRatio = image.width / image.height;
        return (targetRatio < currentRatio ^ size[0] === 'contain') ?  {width: bounds.height * currentRatio, height: bounds.height} : {width: bounds.width, height: bounds.width / currentRatio};
    } else {
        width = parseInt(size[0], 10);
    }

    if (size[0] === 'auto' && size[1] === 'auto') {
        height = image.height;
    } else if (size[1] === 'auto') {
        height = width / image.width * image.height;
    } else if (isPercentage(size[1])) {
        height =  bounds.height * parseFloat(size[1]) / 100;
    } else {
        height = parseInt(size[1], 10);
    }

    if (size[0] === 'auto') {
        width = height / image.height * image.width;
    }

    return {width: width, height: height};
};

NodeContainer.prototype.parseBackgroundPosition = function(bounds, image, index, backgroundSize) {
    var position = this.cssList('backgroundPosition', index);
    var left, top;

    if (isPercentage(position[0])){
        left = (bounds.width - (backgroundSize || image).width) * (parseFloat(position[0]) / 100);
    } else {
        left = parseInt(position[0], 10);
    }

    if (position[1] === 'auto') {
        top = left / image.width * image.height;
    } else if (isPercentage(position[1])){
        top =  (bounds.height - (backgroundSize || image).height) * parseFloat(position[1]) / 100;
    } else {
        top = parseInt(position[1], 10);
    }

    if (position[0] === 'auto') {
        left = top / image.height * image.width;
    }

    return {left: left, top: top};
};

NodeContainer.prototype.parseBackgroundRepeat = function(index) {
    return this.cssList("backgroundRepeat", index)[0];
};

NodeContainer.prototype.parseTextShadows = function() {
    var textShadow = this.css("textShadow");
    var results = [];

    if (textShadow && textShadow !== 'none') {
        var shadows = textShadow.match(this.TEXT_SHADOW_PROPERTY);
        for (var i = 0; shadows && (i < shadows.length); i++) {
            var s = shadows[i].match(this.TEXT_SHADOW_VALUES);
            results.push({
                color: new Color(s[0]),
                offsetX: s[1] ? parseFloat(s[1].replace('px', '')) : 0,
                offsetY: s[2] ? parseFloat(s[2].replace('px', '')) : 0,
                blur: s[3] ? s[3].replace('px', '') : 0
            });
        }
    }
    return results;
};

NodeContainer.prototype.parseTransform = function() {
    if (!this.transformData) {
        if (this.hasTransform()) {
            var offset = this.parseBounds();
            var origin = this.prefixedCss("transformOrigin").split(" ").map(removePx).map(asFloat);
            origin[0] += offset.left;
            origin[1] += offset.top;
            this.transformData = {
                origin: origin,
                matrix: this.parseTransformMatrix()
            };
        } else {
            this.transformData = {
                origin: [0, 0],
                matrix: [1, 0, 0, 1, 0, 0]
            };
        }
    }
    return this.transformData;
};

NodeContainer.prototype.parseTransformMatrix = function() {
    if (!this.transformMatrix) {
        var transform = this.prefixedCss("transform");
        var matrix = transform ? parseMatrix(transform.match(this.MATRIX_PROPERTY)) : null;
        this.transformMatrix = matrix ? matrix : [1, 0, 0, 1, 0, 0];
    }
    return this.transformMatrix;
};

NodeContainer.prototype.parseBounds = function() {
    return this.bounds || (this.bounds = this.hasTransform() ? offsetBounds(this.node) : getBounds(this.node));
};

NodeContainer.prototype.hasTransform = function() {
    return this.parseTransformMatrix().join(",") !== "1,0,0,1,0,0" || (this.parent && this.parent.hasTransform());
};

NodeContainer.prototype.getValue = function() {
    var value = this.node.value || "";
    if (this.node.tagName === "SELECT") {
        value = selectionValue(this.node);
    } else if (this.node.type === "password") {
        value = Array(value.length + 1).join('\u2022'); // jshint ignore:line
    }
    return value.length === 0 ? (this.node.placeholder || "") : value;
};

NodeContainer.prototype.MATRIX_PROPERTY = /(matrix|matrix3d)\((.+)\)/;
NodeContainer.prototype.TEXT_SHADOW_PROPERTY = /((rgba|rgb)\([^\)]+\)(\s-?\d+px){0,})/g;
NodeContainer.prototype.TEXT_SHADOW_VALUES = /(-?\d+px)|(#.+)|(rgb\(.+\))|(rgba\(.+\))/g;
NodeContainer.prototype.CLIP = /^rect\((\d+)px,? (\d+)px,? (\d+)px,? (\d+)px\)$/;

function selectionValue(node) {
    var option = node.options[node.selectedIndex || 0];
    return option ? (option.text || "") : "";
}

function parseMatrix(match) {
    if (match && match[1] === "matrix") {
        return match[2].split(",").map(function(s) {
            return parseFloat(s.trim());
        });
    } else if (match && match[1] === "matrix3d") {
        var matrix3d = match[2].split(",").map(function(s) {
          return parseFloat(s.trim());
        });
        return [matrix3d[0], matrix3d[1], matrix3d[4], matrix3d[5], matrix3d[12], matrix3d[13]];
    }
}

function isPercentage(value) {
    return value.toString().indexOf("%") !== -1;
}

function removePx(str) {
    return str.replace("px", "");
}

function asFloat(str) {
    return parseFloat(str);
}

module.exports = NodeContainer;

},{"./color":3,"./utils":26}],15:[function(_dereq_,module,exports){
var log = _dereq_('./log');
var punycode = _dereq_('punycode');
var NodeContainer = _dereq_('./nodecontainer');
var TextContainer = _dereq_('./textcontainer');
var PseudoElementContainer = _dereq_('./pseudoelementcontainer');
var FontMetrics = _dereq_('./fontmetrics');
var Color = _dereq_('./color');
var StackingContext = _dereq_('./stackingcontext');
var utils = _dereq_('./utils');
var bind = utils.bind;
var getBounds = utils.getBounds;
var parseBackgrounds = utils.parseBackgrounds;
var offsetBounds = utils.offsetBounds;

function NodeParser(element, renderer, support, imageLoader, options) {
    log("Starting NodeParser");
    this.renderer = renderer;
    this.options = options;
    this.range = null;
    this.support = support;
    this.renderQueue = [];
    this.stack = new StackingContext(true, 1, element.ownerDocument, null);
    var parent = new NodeContainer(element, null);
    if (options.background) {
        renderer.rectangle(0, 0, renderer.width, renderer.height, new Color(options.background));
    }
    if (element === element.ownerDocument.documentElement) {
        // http://www.w3.org/TR/css3-background/#special-backgrounds
        var canvasBackground = new NodeContainer(parent.color('backgroundColor').isTransparent() ? element.ownerDocument.body : element.ownerDocument.documentElement, null);
        renderer.rectangle(0, 0, renderer.width, renderer.height, canvasBackground.color('backgroundColor'));
    }
    parent.visibile = parent.isElementVisible();
    this.createPseudoHideStyles(element.ownerDocument);
    this.disableAnimations(element.ownerDocument);
    this.nodes = flatten([parent].concat(this.getChildren(parent)).filter(function(container) {
        return container.visible = container.isElementVisible();
    }).map(this.getPseudoElements, this));
    this.fontMetrics = new FontMetrics();
    log("Fetched nodes, total:", this.nodes.length);
    log("Calculate overflow clips");
    this.calculateOverflowClips();
    log("Start fetching images");
    this.images = imageLoader.fetch(this.nodes.filter(isElement));
    this.ready = this.images.ready.then(bind(function() {
        log("Images loaded, starting parsing");
        log("Creating stacking contexts");
        this.createStackingContexts();
        log("Sorting stacking contexts");
        this.sortStackingContexts(this.stack);
        this.parse(this.stack);
        log("Render queue created with " + this.renderQueue.length + " items");
        return new Promise(bind(function(resolve) {
            if (!options.async) {
                this.renderQueue.forEach(this.paint, this);
                resolve();
            } else if (typeof(options.async) === "function") {
                options.async.call(this, this.renderQueue, resolve);
            } else if (this.renderQueue.length > 0){
                this.renderIndex = 0;
                this.asyncRenderer(this.renderQueue, resolve);
            } else {
                resolve();
            }
        }, this));
    }, this));
}

NodeParser.prototype.calculateOverflowClips = function() {
    this.nodes.forEach(function(container) {
        if (isElement(container)) {
            if (isPseudoElement(container)) {
                container.appendToDOM();
            }
            container.borders = this.parseBorders(container);
            var clip = (container.css('overflow') === "hidden") ? [container.borders.clip] : [];
            var cssClip = container.parseClip();
            if (cssClip && ["absolute", "fixed"].indexOf(container.css('position')) !== -1) {
                clip.push([["rect",
                        container.bounds.left + cssClip.left,
                        container.bounds.top + cssClip.top,
                        cssClip.right - cssClip.left,
                        cssClip.bottom - cssClip.top
                ]]);
            }
            container.clip = hasParentClip(container) ? container.parent.clip.concat(clip) : clip;
            container.backgroundClip = (container.css('overflow') !== "hidden") ? container.clip.concat([container.borders.clip]) : container.clip;
            if (isPseudoElement(container)) {
                container.cleanDOM();
            }
        } else if (isTextNode(container)) {
            container.clip = hasParentClip(container) ? container.parent.clip : [];
        }
        if (!isPseudoElement(container)) {
            container.bounds = null;
        }
    }, this);
};

function hasParentClip(container) {
    return container.parent && container.parent.clip.length;
}

NodeParser.prototype.asyncRenderer = function(queue, resolve, asyncTimer) {
    asyncTimer = asyncTimer || Date.now();
    this.paint(queue[this.renderIndex++]);
    if (queue.length === this.renderIndex) {
        resolve();
    } else if (asyncTimer + 20 > Date.now()) {
        this.asyncRenderer(queue, resolve, asyncTimer);
    } else {
        setTimeout(bind(function() {
            this.asyncRenderer(queue, resolve);
        }, this), 0);
    }
};

NodeParser.prototype.createPseudoHideStyles = function(document) {
    this.createStyles(document, '.' + PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + ':before { content: "" !important; display: none !important; }' +
        '.' + PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER + ':after { content: "" !important; display: none !important; }');
};

NodeParser.prototype.disableAnimations = function(document) {
    this.createStyles(document, '* { -webkit-animation: none !important; -moz-animation: none !important; -o-animation: none !important; animation: none !important; ' +
        '-webkit-transition: none !important; -moz-transition: none !important; -o-transition: none !important; transition: none !important;}');
};

NodeParser.prototype.createStyles = function(document, styles) {
    var hidePseudoElements = document.createElement('style');
    hidePseudoElements.innerHTML = styles;
    document.body.appendChild(hidePseudoElements);
};

NodeParser.prototype.getPseudoElements = function(container) {
    var nodes = [[container]];
    if (container.node.nodeType === Node.ELEMENT_NODE) {
        var before = this.getPseudoElement(container, ":before");
        var after = this.getPseudoElement(container, ":after");

        if (before) {
            nodes.push(before);
        }

        if (after) {
            nodes.push(after);
        }
    }
    return flatten(nodes);
};

function toCamelCase(str) {
    return str.replace(/(\-[a-z])/g, function(match){
        return match.toUpperCase().replace('-','');
    });
}

NodeParser.prototype.getPseudoElement = function(container, type) {
    var style = container.computedStyle(type);
    if(!style || !style.content || style.content === "none" || style.content === "-moz-alt-content" || style.display === "none") {
        return null;
    }

    var content = stripQuotes(style.content);
    var isImage = content.substr(0, 3) === 'url';
    var pseudoNode = document.createElement(isImage ? 'img' : 'html2canvaspseudoelement');
    var pseudoContainer = new PseudoElementContainer(pseudoNode, container, type);

    for (var i = style.length-1; i >= 0; i--) {
        var property = toCamelCase(style.item(i));
        pseudoNode.style[property] = style[property];
    }

    pseudoNode.className = PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + " " + PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER;

    if (isImage) {
        pseudoNode.src = parseBackgrounds(content)[0].args[0];
        return [pseudoContainer];
    } else {
        var text = document.createTextNode(content);
        pseudoNode.appendChild(text);
        return [pseudoContainer, new TextContainer(text, pseudoContainer)];
    }
};


NodeParser.prototype.getChildren = function(parentContainer) {
    return flatten([].filter.call(parentContainer.node.childNodes, renderableNode).map(function(node) {
        var container = [node.nodeType === Node.TEXT_NODE ? new TextContainer(node, parentContainer) : new NodeContainer(node, parentContainer)].filter(nonIgnoredElement);
        return node.nodeType === Node.ELEMENT_NODE && container.length && node.tagName !== "TEXTAREA" ? (container[0].isElementVisible() ? container.concat(this.getChildren(container[0])) : []) : container;
    }, this));
};

NodeParser.prototype.newStackingContext = function(container, hasOwnStacking) {
    var stack = new StackingContext(hasOwnStacking, container.getOpacity(), container.node, container.parent);
    container.cloneTo(stack);
    var parentStack = hasOwnStacking ? stack.getParentStack(this) : stack.parent.stack;
    parentStack.contexts.push(stack);
    container.stack = stack;
};

NodeParser.prototype.createStackingContexts = function() {
    this.nodes.forEach(function(container) {
        if (isElement(container) && (this.isRootElement(container) || hasOpacity(container) || isPositionedForStacking(container) || this.isBodyWithTransparentRoot(container) || container.hasTransform())) {
            this.newStackingContext(container, true);
        } else if (isElement(container) && ((isPositioned(container) && zIndex0(container)) || isInlineBlock(container) || isFloating(container))) {
            this.newStackingContext(container, false);
        } else {
            container.assignStack(container.parent.stack);
        }
    }, this);
};

NodeParser.prototype.isBodyWithTransparentRoot = function(container) {
    return container.node.nodeName === "BODY" && container.parent.color('backgroundColor').isTransparent();
};

NodeParser.prototype.isRootElement = function(container) {
    return container.parent === null;
};

NodeParser.prototype.sortStackingContexts = function(stack) {
    stack.contexts.sort(zIndexSort(stack.contexts.slice(0)));
    stack.contexts.forEach(this.sortStackingContexts, this);
};

NodeParser.prototype.parseTextBounds = function(container) {
    return function(text, index, textList) {
        if (container.parent.css("textDecoration").substr(0, 4) !== "none" || text.trim().length !== 0) {
            if (this.support.rangeBounds && !container.parent.hasTransform()) {
                var offset = textList.slice(0, index).join("").length;
                return this.getRangeBounds(container.node, offset, text.length);
            } else if (container.node && typeof(container.node.data) === "string") {
                var replacementNode = container.node.splitText(text.length);
                var bounds = this.getWrapperBounds(container.node, container.parent.hasTransform());
                container.node = replacementNode;
                return bounds;
            }
        } else if(!this.support.rangeBounds || container.parent.hasTransform()){
            container.node = container.node.splitText(text.length);
        }
        return {};
    };
};

NodeParser.prototype.getWrapperBounds = function(node, transform) {
    var wrapper = node.ownerDocument.createElement('html2canvaswrapper');
    var parent = node.parentNode,
        backupText = node.cloneNode(true);

    wrapper.appendChild(node.cloneNode(true));
    parent.replaceChild(wrapper, node);
    var bounds = transform ? offsetBounds(wrapper) : getBounds(wrapper);
    parent.replaceChild(backupText, wrapper);
    return bounds;
};

NodeParser.prototype.getRangeBounds = function(node, offset, length) {
    var range = this.range || (this.range = node.ownerDocument.createRange());
    range.setStart(node, offset);
    range.setEnd(node, offset + length);
    return range.getBoundingClientRect();
};

function ClearTransform() {}

NodeParser.prototype.parse = function(stack) {
    // http://www.w3.org/TR/CSS21/visuren.html#z-index
    var negativeZindex = stack.contexts.filter(negativeZIndex); // 2. the child stacking contexts with negative stack levels (most negative first).
    var descendantElements = stack.children.filter(isElement);
    var descendantNonFloats = descendantElements.filter(not(isFloating));
    var nonInlineNonPositionedDescendants = descendantNonFloats.filter(not(isPositioned)).filter(not(inlineLevel)); // 3 the in-flow, non-inline-level, non-positioned descendants.
    var nonPositionedFloats = descendantElements.filter(not(isPositioned)).filter(isFloating); // 4. the non-positioned floats.
    var inFlow = descendantNonFloats.filter(not(isPositioned)).filter(inlineLevel); // 5. the in-flow, inline-level, non-positioned descendants, including inline tables and inline blocks.
    var stackLevel0 = stack.contexts.concat(descendantNonFloats.filter(isPositioned)).filter(zIndex0); // 6. the child stacking contexts with stack level 0 and the positioned descendants with stack level 0.
    var text = stack.children.filter(isTextNode).filter(hasText);
    var positiveZindex = stack.contexts.filter(positiveZIndex); // 7. the child stacking contexts with positive stack levels (least positive first).
    negativeZindex.concat(nonInlineNonPositionedDescendants).concat(nonPositionedFloats)
        .concat(inFlow).concat(stackLevel0).concat(text).concat(positiveZindex).forEach(function(container) {
            this.renderQueue.push(container);
            if (isStackingContext(container)) {
                this.parse(container);
                this.renderQueue.push(new ClearTransform());
            }
        }, this);
};

NodeParser.prototype.paint = function(container) {
    try {
        if (container instanceof ClearTransform) {
            this.renderer.ctx.restore();
        } else if (isTextNode(container)) {
            if (isPseudoElement(container.parent)) {
                container.parent.appendToDOM();
            }
            this.paintText(container);
            if (isPseudoElement(container.parent)) {
                container.parent.cleanDOM();
            }
        } else {
            this.paintNode(container);
        }
    } catch(e) {
        log(e);
        if (this.options.strict) {
            throw e;
        }
    }
};

NodeParser.prototype.paintNode = function(container) {
    if (isStackingContext(container)) {
        this.renderer.setOpacity(container.opacity);
        this.renderer.ctx.save();
        if (container.hasTransform()) {
            this.renderer.setTransform(container.parseTransform());
        }
    }

    if (container.node.nodeName === "INPUT" && container.node.type === "checkbox") {
        this.paintCheckbox(container);
    } else if (container.node.nodeName === "INPUT" && container.node.type === "radio") {
        this.paintRadio(container);
    } else {
        this.paintElement(container);
    }
};

NodeParser.prototype.paintElement = function(container) {
    var bounds = container.parseBounds();
    this.renderer.clip(container.backgroundClip, function() {
        this.renderer.renderBackground(container, bounds, container.borders.borders.map(getWidth));
    }, this);

    this.renderer.clip(container.clip, function() {
        this.renderer.renderBorders(container.borders.borders);
    }, this);

    this.renderer.clip(container.backgroundClip, function() {
        switch (container.node.nodeName) {
        case "svg":
        case "IFRAME":
            var imgContainer = this.images.get(container.node);
            if (imgContainer) {
                this.renderer.renderImage(container, bounds, container.borders, imgContainer);
            } else {
                log("Error loading <" + container.node.nodeName + ">", container.node);
            }
            break;
        case "IMG":
            var imageContainer = this.images.get(container.node.src);
            if (imageContainer) {
                this.renderer.renderImage(container, bounds, container.borders, imageContainer);
            } else {
                log("Error loading <img>", container.node.src);
            }
            break;
        case "CANVAS":
            this.renderer.renderImage(container, bounds, container.borders, {image: container.node});
            break;
        case "SELECT":
        case "INPUT":
        case "TEXTAREA":
            this.paintFormValue(container);
            break;
        }
    }, this);
};

NodeParser.prototype.paintCheckbox = function(container) {
    var b = container.parseBounds();

    var size = Math.min(b.width, b.height);
    var bounds = {width: size - 1, height: size - 1, top: b.top, left: b.left};
    var r = [3, 3];
    var radius = [r, r, r, r];
    var borders = [1,1,1,1].map(function(w) {
        return {color: new Color('#A5A5A5'), width: w};
    });

    var borderPoints = calculateCurvePoints(bounds, radius, borders);

    this.renderer.clip(container.backgroundClip, function() {
        this.renderer.rectangle(bounds.left + 1, bounds.top + 1, bounds.width - 2, bounds.height - 2, new Color("#DEDEDE"));
        this.renderer.renderBorders(calculateBorders(borders, bounds, borderPoints, radius));
        if (container.node.checked) {
            this.renderer.font(new Color('#424242'), 'normal', 'normal', 'bold', (size - 3) + "px", 'arial');
            this.renderer.text("\u2714", bounds.left + size / 6, bounds.top + size - 1);
        }
    }, this);
};

NodeParser.prototype.paintRadio = function(container) {
    var bounds = container.parseBounds();

    var size = Math.min(bounds.width, bounds.height) - 2;

    this.renderer.clip(container.backgroundClip, function() {
        this.renderer.circleStroke(bounds.left + 1, bounds.top + 1, size, new Color('#DEDEDE'), 1, new Color('#A5A5A5'));
        if (container.node.checked) {
            this.renderer.circle(Math.ceil(bounds.left + size / 4) + 1, Math.ceil(bounds.top + size / 4) + 1, Math.floor(size / 2), new Color('#424242'));
        }
    }, this);
};

NodeParser.prototype.paintFormValue = function(container) {
    var value = container.getValue();
    if (value.length > 0) {
        var document = container.node.ownerDocument;
        var wrapper = document.createElement('html2canvaswrapper');
        var properties = ['lineHeight', 'textAlign', 'fontFamily', 'fontWeight', 'fontSize', 'color',
            'paddingLeft', 'paddingTop', 'paddingRight', 'paddingBottom',
            'width', 'height', 'borderLeftStyle', 'borderTopStyle', 'borderLeftWidth', 'borderTopWidth',
            'boxSizing', 'whiteSpace', 'wordWrap'];

        properties.forEach(function(property) {
            try {
                wrapper.style[property] = container.css(property);
            } catch(e) {
                // Older IE has issues with "border"
                log("html2canvas: Parse: Exception caught in renderFormValue: " + e.message);
            }
        });
        var bounds = container.parseBounds();
        wrapper.style.position = "fixed";
        wrapper.style.left = bounds.left + "px";
        wrapper.style.top = bounds.top + "px";
        wrapper.textContent = value;
        document.body.appendChild(wrapper);
        this.paintText(new TextContainer(wrapper.firstChild, container));
        document.body.removeChild(wrapper);
    }
};

NodeParser.prototype.paintText = function(container) {
    container.applyTextTransform();
    var characters = punycode.ucs2.decode(container.node.data);
    var textList = (!this.options.letterRendering || noLetterSpacing(container)) && !hasUnicode(container.node.data) ? getWords(characters) : characters.map(function(character) {
        return punycode.ucs2.encode([character]);
    });

    var weight = container.parent.fontWeight();
    var size = container.parent.css('fontSize');
    var family = container.parent.css('fontFamily');
    var shadows = container.parent.parseTextShadows();

    this.renderer.font(container.parent.color('color'), container.parent.css('fontStyle'), container.parent.css('fontVariant'), weight, size, family);
    if (shadows.length) {
        // TODO: support multiple text shadows
        this.renderer.fontShadow(shadows[0].color, shadows[0].offsetX, shadows[0].offsetY, shadows[0].blur);
    } else {
        this.renderer.clearShadow();
    }

    this.renderer.clip(container.parent.clip, function() {
        textList.map(this.parseTextBounds(container), this).forEach(function(bounds, index) {
            if (bounds) {
                this.renderer.text(textList[index], bounds.left, bounds.bottom);
                this.renderTextDecoration(container.parent, bounds, this.fontMetrics.getMetrics(family, size));
            }
        }, this);
    }, this);
};

NodeParser.prototype.renderTextDecoration = function(container, bounds, metrics) {
    switch(container.css("textDecoration").split(" ")[0]) {
    case "underline":
        // Draws a line at the baseline of the font
        // TODO As some browsers display the line as more than 1px if the font-size is big, need to take that into account both in position and size
        this.renderer.rectangle(bounds.left, Math.round(bounds.top + metrics.baseline + metrics.lineWidth), bounds.width, 1, container.color("color"));
        break;
    case "overline":
        this.renderer.rectangle(bounds.left, Math.round(bounds.top), bounds.width, 1, container.color("color"));
        break;
    case "line-through":
        // TODO try and find exact position for line-through
        this.renderer.rectangle(bounds.left, Math.ceil(bounds.top + metrics.middle + metrics.lineWidth), bounds.width, 1, container.color("color"));
        break;
    }
};

var borderColorTransforms = {
    inset: [
        ["darken", 0.60],
        ["darken", 0.10],
        ["darken", 0.10],
        ["darken", 0.60]
    ]
};

NodeParser.prototype.parseBorders = function(container) {
    var nodeBounds = container.parseBounds();
    var radius = getBorderRadiusData(container);
    var borders = ["Top", "Right", "Bottom", "Left"].map(function(side, index) {
        var style = container.css('border' + side + 'Style');
        var color = container.color('border' + side + 'Color');
        if (style === "inset" && color.isBlack()) {
            color = new Color([255, 255, 255, color.a]); // this is wrong, but
        }
        var colorTransform = borderColorTransforms[style] ? borderColorTransforms[style][index] : null;
        return {
            width: container.cssInt('border' + side + 'Width'),
            color: colorTransform ? color[colorTransform[0]](colorTransform[1]) : color,
            args: null
        };
    });
    var borderPoints = calculateCurvePoints(nodeBounds, radius, borders);

    return {
        clip: this.parseBackgroundClip(container, borderPoints, borders, radius, nodeBounds),
        borders: calculateBorders(borders, nodeBounds, borderPoints, radius)
    };
};

function calculateBorders(borders, nodeBounds, borderPoints, radius) {
    return borders.map(function(border, borderSide) {
        if (border.width > 0) {
            var bx = nodeBounds.left;
            var by = nodeBounds.top;
            var bw = nodeBounds.width;
            var bh = nodeBounds.height - (borders[2].width);

            switch(borderSide) {
            case 0:
                // top border
                bh = borders[0].width;
                border.args = drawSide({
                        c1: [bx, by],
                        c2: [bx + bw, by],
                        c3: [bx + bw - borders[1].width, by + bh],
                        c4: [bx + borders[3].width, by + bh]
                    }, radius[0], radius[1],
                    borderPoints.topLeftOuter, borderPoints.topLeftInner, borderPoints.topRightOuter, borderPoints.topRightInner);
                break;
            case 1:
                // right border
                bx = nodeBounds.left + nodeBounds.width - (borders[1].width);
                bw = borders[1].width;

                border.args = drawSide({
                        c1: [bx + bw, by],
                        c2: [bx + bw, by + bh + borders[2].width],
                        c3: [bx, by + bh],
                        c4: [bx, by + borders[0].width]
                    }, radius[1], radius[2],
                    borderPoints.topRightOuter, borderPoints.topRightInner, borderPoints.bottomRightOuter, borderPoints.bottomRightInner);
                break;
            case 2:
                // bottom border
                by = (by + nodeBounds.height) - (borders[2].width);
                bh = borders[2].width;
                border.args = drawSide({
                        c1: [bx + bw, by + bh],
                        c2: [bx, by + bh],
                        c3: [bx + borders[3].width, by],
                        c4: [bx + bw - borders[3].width, by]
                    }, radius[2], radius[3],
                    borderPoints.bottomRightOuter, borderPoints.bottomRightInner, borderPoints.bottomLeftOuter, borderPoints.bottomLeftInner);
                break;
            case 3:
                // left border
                bw = borders[3].width;
                border.args = drawSide({
                        c1: [bx, by + bh + borders[2].width],
                        c2: [bx, by],
                        c3: [bx + bw, by + borders[0].width],
                        c4: [bx + bw, by + bh]
                    }, radius[3], radius[0],
                    borderPoints.bottomLeftOuter, borderPoints.bottomLeftInner, borderPoints.topLeftOuter, borderPoints.topLeftInner);
                break;
            }
        }
        return border;
    });
}

NodeParser.prototype.parseBackgroundClip = function(container, borderPoints, borders, radius, bounds) {
    var backgroundClip = container.css('backgroundClip'),
        borderArgs = [];

    switch(backgroundClip) {
    case "content-box":
    case "padding-box":
        parseCorner(borderArgs, radius[0], radius[1], borderPoints.topLeftInner, borderPoints.topRightInner, bounds.left + borders[3].width, bounds.top + borders[0].width);
        parseCorner(borderArgs, radius[1], radius[2], borderPoints.topRightInner, borderPoints.bottomRightInner, bounds.left + bounds.width - borders[1].width, bounds.top + borders[0].width);
        parseCorner(borderArgs, radius[2], radius[3], borderPoints.bottomRightInner, borderPoints.bottomLeftInner, bounds.left + bounds.width - borders[1].width, bounds.top + bounds.height - borders[2].width);
        parseCorner(borderArgs, radius[3], radius[0], borderPoints.bottomLeftInner, borderPoints.topLeftInner, bounds.left + borders[3].width, bounds.top + bounds.height - borders[2].width);
        break;

    default:
        parseCorner(borderArgs, radius[0], radius[1], borderPoints.topLeftOuter, borderPoints.topRightOuter, bounds.left, bounds.top);
        parseCorner(borderArgs, radius[1], radius[2], borderPoints.topRightOuter, borderPoints.bottomRightOuter, bounds.left + bounds.width, bounds.top);
        parseCorner(borderArgs, radius[2], radius[3], borderPoints.bottomRightOuter, borderPoints.bottomLeftOuter, bounds.left + bounds.width, bounds.top + bounds.height);
        parseCorner(borderArgs, radius[3], radius[0], borderPoints.bottomLeftOuter, borderPoints.topLeftOuter, bounds.left, bounds.top + bounds.height);
        break;
    }

    return borderArgs;
};

function getCurvePoints(x, y, r1, r2) {
    var kappa = 4 * ((Math.sqrt(2) - 1) / 3);
    var ox = (r1) * kappa, // control point offset horizontal
        oy = (r2) * kappa, // control point offset vertical
        xm = x + r1, // x-middle
        ym = y + r2; // y-middle
    return {
        topLeft: bezierCurve({x: x, y: ym}, {x: x, y: ym - oy}, {x: xm - ox, y: y}, {x: xm, y: y}),
        topRight: bezierCurve({x: x, y: y}, {x: x + ox,y: y}, {x: xm, y: ym - oy}, {x: xm, y: ym}),
        bottomRight: bezierCurve({x: xm, y: y}, {x: xm, y: y + oy}, {x: x + ox, y: ym}, {x: x, y: ym}),
        bottomLeft: bezierCurve({x: xm, y: ym}, {x: xm - ox, y: ym}, {x: x, y: y + oy}, {x: x, y:y})
    };
}

function calculateCurvePoints(bounds, borderRadius, borders) {
    var x = bounds.left,
        y = bounds.top,
        width = bounds.width,
        height = bounds.height,

        tlh = borderRadius[0][0] < width / 2 ? borderRadius[0][0] : width / 2,
        tlv = borderRadius[0][1] < height / 2 ? borderRadius[0][1] : height / 2,
        trh = borderRadius[1][0] < width / 2 ? borderRadius[1][0] : width / 2,
        trv = borderRadius[1][1] < height / 2 ? borderRadius[1][1] : height / 2,
        brh = borderRadius[2][0] < width / 2 ? borderRadius[2][0] : width / 2,
        brv = borderRadius[2][1] < height / 2 ? borderRadius[2][1] : height / 2,
        blh = borderRadius[3][0] < width / 2 ? borderRadius[3][0] : width / 2,
        blv = borderRadius[3][1] < height / 2 ? borderRadius[3][1] : height / 2;

    var topWidth = width - trh,
        rightHeight = height - brv,
        bottomWidth = width - brh,
        leftHeight = height - blv;

    return {
        topLeftOuter: getCurvePoints(x, y, tlh, tlv).topLeft.subdivide(0.5),
        topLeftInner: getCurvePoints(x + borders[3].width, y + borders[0].width, Math.max(0, tlh - borders[3].width), Math.max(0, tlv - borders[0].width)).topLeft.subdivide(0.5),
        topRightOuter: getCurvePoints(x + topWidth, y, trh, trv).topRight.subdivide(0.5),
        topRightInner: getCurvePoints(x + Math.min(topWidth, width + borders[3].width), y + borders[0].width, (topWidth > width + borders[3].width) ? 0 :trh - borders[3].width, trv - borders[0].width).topRight.subdivide(0.5),
        bottomRightOuter: getCurvePoints(x + bottomWidth, y + rightHeight, brh, brv).bottomRight.subdivide(0.5),
        bottomRightInner: getCurvePoints(x + Math.min(bottomWidth, width - borders[3].width), y + Math.min(rightHeight, height + borders[0].width), Math.max(0, brh - borders[1].width),  brv - borders[2].width).bottomRight.subdivide(0.5),
        bottomLeftOuter: getCurvePoints(x, y + leftHeight, blh, blv).bottomLeft.subdivide(0.5),
        bottomLeftInner: getCurvePoints(x + borders[3].width, y + leftHeight, Math.max(0, blh - borders[3].width), blv - borders[2].width).bottomLeft.subdivide(0.5)
    };
}

function bezierCurve(start, startControl, endControl, end) {
    var lerp = function (a, b, t) {
        return {
            x: a.x + (b.x - a.x) * t,
            y: a.y + (b.y - a.y) * t
        };
    };

    return {
        start: start,
        startControl: startControl,
        endControl: endControl,
        end: end,
        subdivide: function(t) {
            var ab = lerp(start, startControl, t),
                bc = lerp(startControl, endControl, t),
                cd = lerp(endControl, end, t),
                abbc = lerp(ab, bc, t),
                bccd = lerp(bc, cd, t),
                dest = lerp(abbc, bccd, t);
            return [bezierCurve(start, ab, abbc, dest), bezierCurve(dest, bccd, cd, end)];
        },
        curveTo: function(borderArgs) {
            borderArgs.push(["bezierCurve", startControl.x, startControl.y, endControl.x, endControl.y, end.x, end.y]);
        },
        curveToReversed: function(borderArgs) {
            borderArgs.push(["bezierCurve", endControl.x, endControl.y, startControl.x, startControl.y, start.x, start.y]);
        }
    };
}

function drawSide(borderData, radius1, radius2, outer1, inner1, outer2, inner2) {
    var borderArgs = [];

    if (radius1[0] > 0 || radius1[1] > 0) {
        borderArgs.push(["line", outer1[1].start.x, outer1[1].start.y]);
        outer1[1].curveTo(borderArgs);
    } else {
        borderArgs.push([ "line", borderData.c1[0], borderData.c1[1]]);
    }

    if (radius2[0] > 0 || radius2[1] > 0) {
        borderArgs.push(["line", outer2[0].start.x, outer2[0].start.y]);
        outer2[0].curveTo(borderArgs);
        borderArgs.push(["line", inner2[0].end.x, inner2[0].end.y]);
        inner2[0].curveToReversed(borderArgs);
    } else {
        borderArgs.push(["line", borderData.c2[0], borderData.c2[1]]);
        borderArgs.push(["line", borderData.c3[0], borderData.c3[1]]);
    }

    if (radius1[0] > 0 || radius1[1] > 0) {
        borderArgs.push(["line", inner1[1].end.x, inner1[1].end.y]);
        inner1[1].curveToReversed(borderArgs);
    } else {
        borderArgs.push(["line", borderData.c4[0], borderData.c4[1]]);
    }

    return borderArgs;
}

function parseCorner(borderArgs, radius1, radius2, corner1, corner2, x, y) {
    if (radius1[0] > 0 || radius1[1] > 0) {
        borderArgs.push(["line", corner1[0].start.x, corner1[0].start.y]);
        corner1[0].curveTo(borderArgs);
        corner1[1].curveTo(borderArgs);
    } else {
        borderArgs.push(["line", x, y]);
    }

    if (radius2[0] > 0 || radius2[1] > 0) {
        borderArgs.push(["line", corner2[0].start.x, corner2[0].start.y]);
    }
}

function negativeZIndex(container) {
    return container.cssInt("zIndex") < 0;
}

function positiveZIndex(container) {
    return container.cssInt("zIndex") > 0;
}

function zIndex0(container) {
    return container.cssInt("zIndex") === 0;
}

function inlineLevel(container) {
    return ["inline", "inline-block", "inline-table"].indexOf(container.css("display")) !== -1;
}

function isStackingContext(container) {
    return (container instanceof StackingContext);
}

function hasText(container) {
    return container.node.data.trim().length > 0;
}

function noLetterSpacing(container) {
    return (/^(normal|none|0px)$/.test(container.parent.css("letterSpacing")));
}

function getBorderRadiusData(container) {
    return ["TopLeft", "TopRight", "BottomRight", "BottomLeft"].map(function(side) {
        var value = container.css('border' + side + 'Radius');
        var arr = value.split(" ");
        if (arr.length <= 1) {
            arr[1] = arr[0];
        }
        return arr.map(asInt);
    });
}

function renderableNode(node) {
    return (node.nodeType === Node.TEXT_NODE || node.nodeType === Node.ELEMENT_NODE);
}

function isPositionedForStacking(container) {
    var position = container.css("position");
    var zIndex = (["absolute", "relative", "fixed"].indexOf(position) !== -1) ? container.css("zIndex") : "auto";
    return zIndex !== "auto";
}

function isPositioned(container) {
    return container.css("position") !== "static";
}

function isFloating(container) {
    return container.css("float") !== "none";
}

function isInlineBlock(container) {
    return ["inline-block", "inline-table"].indexOf(container.css("display")) !== -1;
}

function not(callback) {
    var context = this;
    return function() {
        return !callback.apply(context, arguments);
    };
}

function isElement(container) {
    return container.node.nodeType === Node.ELEMENT_NODE;
}

function isPseudoElement(container) {
    return container.isPseudoElement === true;
}

function isTextNode(container) {
    return container.node.nodeType === Node.TEXT_NODE;
}

function zIndexSort(contexts) {
    return function(a, b) {
        return (a.cssInt("zIndex") + (contexts.indexOf(a) / contexts.length)) - (b.cssInt("zIndex") + (contexts.indexOf(b) / contexts.length));
    };
}

function hasOpacity(container) {
    return container.getOpacity() < 1;
}

function asInt(value) {
    return parseInt(value, 10);
}

function getWidth(border) {
    return border.width;
}

function nonIgnoredElement(nodeContainer) {
    return (nodeContainer.node.nodeType !== Node.ELEMENT_NODE || ["SCRIPT", "HEAD", "TITLE", "OBJECT", "BR", "OPTION"].indexOf(nodeContainer.node.nodeName) === -1);
}

function flatten(arrays) {
    return [].concat.apply([], arrays);
}

function stripQuotes(content) {
    var first = content.substr(0, 1);
    return (first === content.substr(content.length - 1) && first.match(/'|"/)) ? content.substr(1, content.length - 2) : content;
}

function getWords(characters) {
    var words = [], i = 0, onWordBoundary = false, word;
    while(characters.length) {
        if (isWordBoundary(characters[i]) === onWordBoundary) {
            word = characters.splice(0, i);
            if (word.length) {
                words.push(punycode.ucs2.encode(word));
            }
            onWordBoundary =! onWordBoundary;
            i = 0;
        } else {
            i++;
        }

        if (i >= characters.length) {
            word = characters.splice(0, i);
            if (word.length) {
                words.push(punycode.ucs2.encode(word));
            }
        }
    }
    return words;
}

function isWordBoundary(characterCode) {
    return [
        32, // <space>
        13, // \r
        10, // \n
        9, // \t
        45 // -
    ].indexOf(characterCode) !== -1;
}

function hasUnicode(string) {
    return (/[^\u0000-\u00ff]/).test(string);
}

module.exports = NodeParser;

},{"./color":3,"./fontmetrics":7,"./log":13,"./nodecontainer":14,"./pseudoelementcontainer":18,"./stackingcontext":21,"./textcontainer":25,"./utils":26,"punycode":1}],16:[function(_dereq_,module,exports){
var XHR = _dereq_('./xhr');
var utils = _dereq_('./utils');
var log = _dereq_('./log');
var createWindowClone = _dereq_('./clone');
var decode64 = utils.decode64;

function Proxy(src, proxyUrl, document) {
    var supportsCORS = ('withCredentials' in new XMLHttpRequest());
    if (!proxyUrl) {
        return Promise.reject("No proxy configured");
    }
    var callback = createCallback(supportsCORS);
    var url = createProxyUrl(proxyUrl, src, callback);

    return supportsCORS ? XHR(url) : (jsonp(document, url, callback).then(function(response) {
        return decode64(response.content);
    }));
}
var proxyCount = 0;

function ProxyURL(src, proxyUrl, document) {
    var supportsCORSImage = ('crossOrigin' in new Image());
    var callback = createCallback(supportsCORSImage);
    var url = createProxyUrl(proxyUrl, src, callback);
    return (supportsCORSImage ? Promise.resolve(url) : jsonp(document, url, callback).then(function(response) {
        return "data:" + response.type + ";base64," + response.content;
    }));
}

function jsonp(document, url, callback) {
    return new Promise(function(resolve, reject) {
        var s = document.createElement("script");
        var cleanup = function() {
            delete window.html2canvas.proxy[callback];
            document.body.removeChild(s);
        };
        window.html2canvas.proxy[callback] = function(response) {
            cleanup();
            resolve(response);
        };
        s.src = url;
        s.onerror = function(e) {
            cleanup();
            reject(e);
        };
        document.body.appendChild(s);
    });
}

function createCallback(useCORS) {
    return !useCORS ? "html2canvas_" + Date.now() + "_" + (++proxyCount) + "_" + Math.round(Math.random() * 100000) : "";
}

function createProxyUrl(proxyUrl, src, callback) {
    return proxyUrl + "?url=" + encodeURIComponent(src) + (callback.length ? "&callback=html2canvas.proxy." + callback : "");
}

function documentFromHTML(src) {
    return function(html) {
        var parser = new DOMParser(), doc;
        try {
            doc = parser.parseFromString(html, "text/html");
        } catch(e) {
            log("DOMParser not supported, falling back to createHTMLDocument");
            doc = document.implementation.createHTMLDocument("");
            try {
                doc.open();
                doc.write(html);
                doc.close();
            } catch(ee) {
                log("createHTMLDocument write not supported, falling back to document.body.innerHTML");
                doc.body.innerHTML = html; // ie9 doesnt support writing to documentElement
            }
        }

        var b = doc.querySelector("base");
        if (!b || !b.href.host) {
            var base = doc.createElement("base");
            base.href = src;
            doc.head.insertBefore(base, doc.head.firstChild);
        }

        return doc;
    };
}

function loadUrlDocument(src, proxy, document, width, height, options) {
    return new Proxy(src, proxy, window.document).then(documentFromHTML(src)).then(function(doc) {
        return createWindowClone(doc, document, width, height, options, 0, 0);
    });
}

exports.Proxy = Proxy;
exports.ProxyURL = ProxyURL;
exports.loadUrlDocument = loadUrlDocument;

},{"./clone":2,"./log":13,"./utils":26,"./xhr":28}],17:[function(_dereq_,module,exports){
var ProxyURL = _dereq_('./proxy').ProxyURL;

function ProxyImageContainer(src, proxy) {
    var link = document.createElement("a");
    link.href = src;
    src = link.href;
    this.src = src;
    this.image = new Image();
    var self = this;
    this.promise = new Promise(function(resolve, reject) {
        self.image.crossOrigin = "Anonymous";
        self.image.onload = resolve;
        self.image.onerror = reject;

        new ProxyURL(src, proxy, document).then(function(url) {
            self.image.src = url;
        })['catch'](reject);
    });
}

module.exports = ProxyImageContainer;

},{"./proxy":16}],18:[function(_dereq_,module,exports){
var NodeContainer = _dereq_('./nodecontainer');

function PseudoElementContainer(node, parent, type) {
    NodeContainer.call(this, node, parent);
    this.isPseudoElement = true;
    this.before = type === ":before";
}

PseudoElementContainer.prototype.cloneTo = function(stack) {
    PseudoElementContainer.prototype.cloneTo.call(this, stack);
    stack.isPseudoElement = true;
    stack.before = this.before;
};

PseudoElementContainer.prototype = Object.create(NodeContainer.prototype);

PseudoElementContainer.prototype.appendToDOM = function() {
    if (this.before) {
        this.parent.node.insertBefore(this.node, this.parent.node.firstChild);
    } else {
        this.parent.node.appendChild(this.node);
    }
    this.parent.node.className += " " + this.getHideClass();
};

PseudoElementContainer.prototype.cleanDOM = function() {
    this.node.parentNode.removeChild(this.node);
    this.parent.node.className = this.parent.node.className.replace(this.getHideClass(), "");
};

PseudoElementContainer.prototype.getHideClass = function() {
    return this["PSEUDO_HIDE_ELEMENT_CLASS_" + (this.before ? "BEFORE" : "AFTER")];
};

PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE = "___html2canvas___pseudoelement_before";
PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER = "___html2canvas___pseudoelement_after";

module.exports = PseudoElementContainer;

},{"./nodecontainer":14}],19:[function(_dereq_,module,exports){
var log = _dereq_('./log');

function Renderer(width, height, images, options, document) {
    this.width = width;
    this.height = height;
    this.images = images;
    this.options = options;
    this.document = document;
}

Renderer.prototype.renderImage = function(container, bounds, borderData, imageContainer) {
    var paddingLeft = container.cssInt('paddingLeft'),
        paddingTop = container.cssInt('paddingTop'),
        paddingRight = container.cssInt('paddingRight'),
        paddingBottom = container.cssInt('paddingBottom'),
        borders = borderData.borders;

    var width = bounds.width - (borders[1].width + borders[3].width + paddingLeft + paddingRight);
    var height = bounds.height - (borders[0].width + borders[2].width + paddingTop + paddingBottom);
    this.drawImage(
        imageContainer,
        0,
        0,
        imageContainer.image.width || width,
        imageContainer.image.height || height,
        bounds.left + paddingLeft + borders[3].width,
        bounds.top + paddingTop + borders[0].width,
        width,
        height
    );
};

Renderer.prototype.renderBackground = function(container, bounds, borderData) {
    if (bounds.height > 0 && bounds.width > 0) {
        this.renderBackgroundColor(container, bounds);
        this.renderBackgroundImage(container, bounds, borderData);
    }
};

Renderer.prototype.renderBackgroundColor = function(container, bounds) {
    var color = container.color("backgroundColor");
    if (!color.isTransparent()) {
        this.rectangle(bounds.left, bounds.top, bounds.width, bounds.height, color);
    }
};

Renderer.prototype.renderBorders = function(borders) {
    borders.forEach(this.renderBorder, this);
};

Renderer.prototype.renderBorder = function(data) {
    if (!data.color.isTransparent() && data.args !== null) {
        this.drawShape(data.args, data.color);
    }
};

Renderer.prototype.renderBackgroundImage = function(container, bounds, borderData) {
    var backgroundImages = container.parseBackgroundImages();
    backgroundImages.reverse().forEach(function(backgroundImage, index, arr) {
        switch(backgroundImage.method) {
        case "url":
            var image = this.images.get(backgroundImage.args[0]);
            if (image) {
                this.renderBackgroundRepeating(container, bounds, image, arr.length - (index+1), borderData);
            } else {
                log("Error loading background-image", backgroundImage.args[0]);
            }
            break;
        case "linear-gradient":
        case "gradient":
            var gradientImage = this.images.get(backgroundImage.value);
            if (gradientImage) {
                this.renderBackgroundGradient(gradientImage, bounds, borderData);
            } else {
                log("Error loading background-image", backgroundImage.args[0]);
            }
            break;
        case "none":
            break;
        default:
            log("Unknown background-image type", backgroundImage.args[0]);
        }
    }, this);
};

Renderer.prototype.renderBackgroundRepeating = function(container, bounds, imageContainer, index, borderData) {
    var size = container.parseBackgroundSize(bounds, imageContainer.image, index);
    var position = container.parseBackgroundPosition(bounds, imageContainer.image, index, size);
    var repeat = container.parseBackgroundRepeat(index);
    switch (repeat) {
    case "repeat-x":
    case "repeat no-repeat":
        this.backgroundRepeatShape(imageContainer, position, size, bounds, bounds.left + borderData[3], bounds.top + position.top + borderData[0], 99999, size.height, borderData);
        break;
    case "repeat-y":
    case "no-repeat repeat":
        this.backgroundRepeatShape(imageContainer, position, size, bounds, bounds.left + position.left + borderData[3], bounds.top + borderData[0], size.width, 99999, borderData);
        break;
    case "no-repeat":
        this.backgroundRepeatShape(imageContainer, position, size, bounds, bounds.left + position.left + borderData[3], bounds.top + position.top + borderData[0], size.width, size.height, borderData);
        break;
    default:
        this.renderBackgroundRepeat(imageContainer, position, size, {top: bounds.top, left: bounds.left}, borderData[3], borderData[0]);
        break;
    }
};

module.exports = Renderer;

},{"./log":13}],20:[function(_dereq_,module,exports){
var Renderer = _dereq_('../renderer');
var LinearGradientContainer = _dereq_('../lineargradientcontainer');
var log = _dereq_('../log');

function CanvasRenderer(width, height) {
    Renderer.apply(this, arguments);
    this.canvas = this.options.canvas || this.document.createElement("canvas");
    if (!this.options.canvas) {
        this.canvas.width = width;
        this.canvas.height = height;
    }
    this.ctx = this.canvas.getContext("2d");
    this.taintCtx = this.document.createElement("canvas").getContext("2d");
    this.ctx.textBaseline = "bottom";
    this.variables = {};
    log("Initialized CanvasRenderer with size", width, "x", height);
}

CanvasRenderer.prototype = Object.create(Renderer.prototype);

CanvasRenderer.prototype.setFillStyle = function(fillStyle) {
    this.ctx.fillStyle = typeof(fillStyle) === "object" && !!fillStyle.isColor ? fillStyle.toString() : fillStyle;
    return this.ctx;
};

CanvasRenderer.prototype.rectangle = function(left, top, width, height, color) {
    this.setFillStyle(color).fillRect(left, top, width, height);
};

CanvasRenderer.prototype.circle = function(left, top, size, color) {
    this.setFillStyle(color);
    this.ctx.beginPath();
    this.ctx.arc(left + size / 2, top + size / 2, size / 2, 0, Math.PI*2, true);
    this.ctx.closePath();
    this.ctx.fill();
};

CanvasRenderer.prototype.circleStroke = function(left, top, size, color, stroke, strokeColor) {
    this.circle(left, top, size, color);
    this.ctx.strokeStyle = strokeColor.toString();
    this.ctx.stroke();
};

CanvasRenderer.prototype.drawShape = function(shape, color) {
    this.shape(shape);
    this.setFillStyle(color).fill();
};

CanvasRenderer.prototype.taints = function(imageContainer) {
    if (imageContainer.tainted === null) {
        this.taintCtx.drawImage(imageContainer.image, 0, 0);
        try {
            this.taintCtx.getImageData(0, 0, 1, 1);
            imageContainer.tainted = false;
        } catch(e) {
            this.taintCtx = document.createElement("canvas").getContext("2d");
            imageContainer.tainted = true;
        }
    }

    return imageContainer.tainted;
};

CanvasRenderer.prototype.drawImage = function(imageContainer, sx, sy, sw, sh, dx, dy, dw, dh) {
    if (!this.taints(imageContainer) || this.options.allowTaint) {
        this.ctx.drawImage(imageContainer.image, sx, sy, sw, sh, dx, dy, dw, dh);
    }
};

CanvasRenderer.prototype.clip = function(shapes, callback, context) {
    this.ctx.save();
    shapes.filter(hasEntries).forEach(function(shape) {
        this.shape(shape).clip();
    }, this);
    callback.call(context);
    this.ctx.restore();
};

CanvasRenderer.prototype.shape = function(shape) {
    this.ctx.beginPath();
    shape.forEach(function(point, index) {
        if (point[0] === "rect") {
            this.ctx.rect.apply(this.ctx, point.slice(1));
        } else {
            this.ctx[(index === 0) ? "moveTo" : point[0] + "To" ].apply(this.ctx, point.slice(1));
        }
    }, this);
    this.ctx.closePath();
    return this.ctx;
};

CanvasRenderer.prototype.font = function(color, style, variant, weight, size, family) {
    this.setFillStyle(color).font = [style, variant, weight, size, family].join(" ").split(",")[0];
};

CanvasRenderer.prototype.fontShadow = function(color, offsetX, offsetY, blur) {
    this.setVariable("shadowColor", color.toString())
        .setVariable("shadowOffsetY", offsetX)
        .setVariable("shadowOffsetX", offsetY)
        .setVariable("shadowBlur", blur);
};

CanvasRenderer.prototype.clearShadow = function() {
    this.setVariable("shadowColor", "rgba(0,0,0,0)");
};

CanvasRenderer.prototype.setOpacity = function(opacity) {
    this.ctx.globalAlpha = opacity;
};

CanvasRenderer.prototype.setTransform = function(transform) {
    this.ctx.translate(transform.origin[0], transform.origin[1]);
    this.ctx.transform.apply(this.ctx, transform.matrix);
    this.ctx.translate(-transform.origin[0], -transform.origin[1]);
};

CanvasRenderer.prototype.setVariable = function(property, value) {
    if (this.variables[property] !== value) {
        this.variables[property] = this.ctx[property] = value;
    }

    return this;
};

CanvasRenderer.prototype.text = function(text, left, bottom) {
    this.ctx.fillText(text, left, bottom);
};

CanvasRenderer.prototype.backgroundRepeatShape = function(imageContainer, backgroundPosition, size, bounds, left, top, width, height, borderData) {
    var shape = [
        ["line", Math.round(left), Math.round(top)],
        ["line", Math.round(left + width), Math.round(top)],
        ["line", Math.round(left + width), Math.round(height + top)],
        ["line", Math.round(left), Math.round(height + top)]
    ];
    this.clip([shape], function() {
        this.renderBackgroundRepeat(imageContainer, backgroundPosition, size, bounds, borderData[3], borderData[0]);
    }, this);
};

CanvasRenderer.prototype.renderBackgroundRepeat = function(imageContainer, backgroundPosition, size, bounds, borderLeft, borderTop) {
    var offsetX = Math.round(bounds.left + backgroundPosition.left + borderLeft), offsetY = Math.round(bounds.top + backgroundPosition.top + borderTop);
    this.setFillStyle(this.ctx.createPattern(this.resizeImage(imageContainer, size), "repeat"));
    this.ctx.translate(offsetX, offsetY);
    this.ctx.fill();
    this.ctx.translate(-offsetX, -offsetY);
};

CanvasRenderer.prototype.renderBackgroundGradient = function(gradientImage, bounds) {
    if (gradientImage instanceof LinearGradientContainer) {
        var gradient = this.ctx.createLinearGradient(
            bounds.left + bounds.width * gradientImage.x0,
            bounds.top + bounds.height * gradientImage.y0,
            bounds.left +  bounds.width * gradientImage.x1,
            bounds.top +  bounds.height * gradientImage.y1);
        gradientImage.colorStops.forEach(function(colorStop) {
            gradient.addColorStop(colorStop.stop, colorStop.color.toString());
        });
        this.rectangle(bounds.left, bounds.top, bounds.width, bounds.height, gradient);
    }
};

CanvasRenderer.prototype.resizeImage = function(imageContainer, size) {
    var image = imageContainer.image;
    if(image.width === size.width && image.height === size.height) {
        return image;
    }

    var ctx, canvas = document.createElement('canvas');
    canvas.width = size.width;
    canvas.height = size.height;
    ctx = canvas.getContext("2d");
    ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, size.width, size.height );
    return canvas;
};

function hasEntries(array) {
    return array.length > 0;
}

module.exports = CanvasRenderer;

},{"../lineargradientcontainer":12,"../log":13,"../renderer":19}],21:[function(_dereq_,module,exports){
var NodeContainer = _dereq_('./nodecontainer');

function StackingContext(hasOwnStacking, opacity, element, parent) {
    NodeContainer.call(this, element, parent);
    this.ownStacking = hasOwnStacking;
    this.contexts = [];
    this.children = [];
    this.opacity = (this.parent ? this.parent.stack.opacity : 1) * opacity;
}

StackingContext.prototype = Object.create(NodeContainer.prototype);

StackingContext.prototype.getParentStack = function(context) {
    var parentStack = (this.parent) ? this.parent.stack : null;
    return parentStack ? (parentStack.ownStacking ? parentStack : parentStack.getParentStack(context)) : context.stack;
};

module.exports = StackingContext;

},{"./nodecontainer":14}],22:[function(_dereq_,module,exports){
function Support(document) {
    this.rangeBounds = this.testRangeBounds(document);
    this.cors = this.testCORS();
    this.svg = this.testSVG();
}

Support.prototype.testRangeBounds = function(document) {
    var range, testElement, rangeBounds, rangeHeight, support = false;

    if (document.createRange) {
        range = document.createRange();
        if (range.getBoundingClientRect) {
            testElement = document.createElement('boundtest');
            testElement.style.height = "123px";
            testElement.style.display = "block";
            document.body.appendChild(testElement);

            range.selectNode(testElement);
            rangeBounds = range.getBoundingClientRect();
            rangeHeight = rangeBounds.height;

            if (rangeHeight === 123) {
                support = true;
            }
            document.body.removeChild(testElement);
        }
    }

    return support;
};

Support.prototype.testCORS = function() {
    return typeof((new Image()).crossOrigin) !== "undefined";
};

Support.prototype.testSVG = function() {
    var img = new Image();
    var canvas = document.createElement("canvas");
    var ctx =  canvas.getContext("2d");
    img.src = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>";

    try {
        ctx.drawImage(img, 0, 0);
        canvas.toDataURL();
    } catch(e) {
        return false;
    }
    return true;
};

module.exports = Support;

},{}],23:[function(_dereq_,module,exports){
var XHR = _dereq_('./xhr');
var decode64 = _dereq_('./utils').decode64;

function SVGContainer(src) {
    this.src = src;
    this.image = null;
    var self = this;

    this.promise = this.hasFabric().then(function() {
        return (self.isInline(src) ? Promise.resolve(self.inlineFormatting(src)) : XHR(src));
    }).then(function(svg) {
        return new Promise(function(resolve) {
            window.html2canvas.svg.fabric.loadSVGFromString(svg, self.createCanvas.call(self, resolve));
        });
    });
}

SVGContainer.prototype.hasFabric = function() {
    return !window.html2canvas.svg || !window.html2canvas.svg.fabric ? Promise.reject(new Error("html2canvas.svg.js is not loaded, cannot render svg")) : Promise.resolve();
};

SVGContainer.prototype.inlineFormatting = function(src) {
    return (/^data:image\/svg\+xml;base64,/.test(src)) ? this.decode64(this.removeContentType(src)) : this.removeContentType(src);
};

SVGContainer.prototype.removeContentType = function(src) {
    return src.replace(/^data:image\/svg\+xml(;base64)?,/,'');
};

SVGContainer.prototype.isInline = function(src) {
    return (/^data:image\/svg\+xml/i.test(src));
};

SVGContainer.prototype.createCanvas = function(resolve) {
    var self = this;
    return function (objects, options) {
        var canvas = new window.html2canvas.svg.fabric.StaticCanvas('c');
        self.image = canvas.lowerCanvasEl;
        canvas
            .setWidth(options.width)
            .setHeight(options.height)
            .add(window.html2canvas.svg.fabric.util.groupSVGElements(objects, options))
            .renderAll();
        resolve(canvas.lowerCanvasEl);
    };
};

SVGContainer.prototype.decode64 = function(str) {
    return (typeof(window.atob) === "function") ? window.atob(str) : decode64(str);
};

module.exports = SVGContainer;

},{"./utils":26,"./xhr":28}],24:[function(_dereq_,module,exports){
var SVGContainer = _dereq_('./svgcontainer');

function SVGNodeContainer(node, _native) {
    this.src = node;
    this.image = null;
    var self = this;

    this.promise = _native ? new Promise(function(resolve, reject) {
        self.image = new Image();
        self.image.onload = resolve;
        self.image.onerror = reject;
        self.image.src = "data:image/svg+xml," + (new XMLSerializer()).serializeToString(node);
        if (self.image.complete === true) {
            resolve(self.image);
        }
    }) : this.hasFabric().then(function() {
        return new Promise(function(resolve) {
            window.html2canvas.svg.fabric.parseSVGDocument(node, self.createCanvas.call(self, resolve));
        });
    });
}

SVGNodeContainer.prototype = Object.create(SVGContainer.prototype);

module.exports = SVGNodeContainer;

},{"./svgcontainer":23}],25:[function(_dereq_,module,exports){
var NodeContainer = _dereq_('./nodecontainer');

function TextContainer(node, parent) {
    NodeContainer.call(this, node, parent);
}

TextContainer.prototype = Object.create(NodeContainer.prototype);

TextContainer.prototype.applyTextTransform = function() {
    this.node.data = this.transform(this.parent.css("textTransform"));
};

TextContainer.prototype.transform = function(transform) {
    var text = this.node.data;
    switch(transform){
        case "lowercase":
            return text.toLowerCase();
        case "capitalize":
            return text.replace(/(^|\s|:|-|\(|\))([a-z])/g, capitalize);
        case "uppercase":
            return text.toUpperCase();
        default:
            return text;
    }
};

function capitalize(m, p1, p2) {
    if (m.length > 0) {
        return p1 + p2.toUpperCase();
    }
}

module.exports = TextContainer;

},{"./nodecontainer":14}],26:[function(_dereq_,module,exports){
exports.smallImage = function smallImage() {
    return "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
};

exports.bind = function(callback, context) {
    return function() {
        return callback.apply(context, arguments);
    };
};

/*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */

exports.decode64 = function(base64) {
    var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var len = base64.length, i, encoded1, encoded2, encoded3, encoded4, byte1, byte2, byte3;

    var output = "";

    for (i = 0; i < len; i+=4) {
        encoded1 = chars.indexOf(base64[i]);
        encoded2 = chars.indexOf(base64[i+1]);
        encoded3 = chars.indexOf(base64[i+2]);
        encoded4 = chars.indexOf(base64[i+3]);

        byte1 = (encoded1 << 2) | (encoded2 >> 4);
        byte2 = ((encoded2 & 15) << 4) | (encoded3 >> 2);
        byte3 = ((encoded3 & 3) << 6) | encoded4;
        if (encoded3 === 64) {
            output += String.fromCharCode(byte1);
        } else if (encoded4 === 64 || encoded4 === -1) {
            output += String.fromCharCode(byte1, byte2);
        } else{
            output += String.fromCharCode(byte1, byte2, byte3);
        }
    }

    return output;
};

exports.getBounds = function(node) {
    if (node.getBoundingClientRect) {
        var clientRect = node.getBoundingClientRect();
        var width = node.offsetWidth == null ? clientRect.width : node.offsetWidth;
        return {
            top: clientRect.top,
            bottom: clientRect.bottom || (clientRect.top + clientRect.height),
            right: clientRect.left + width,
            left: clientRect.left,
            width:  width,
            height: node.offsetHeight == null ? clientRect.height : node.offsetHeight
        };
    }
    return {};
};

exports.offsetBounds = function(node) {
    var parent = node.offsetParent ? exports.offsetBounds(node.offsetParent) : {top: 0, left: 0};

    return {
        top: node.offsetTop + parent.top,
        bottom: node.offsetTop + node.offsetHeight + parent.top,
        right: node.offsetLeft + parent.left + node.offsetWidth,
        left: node.offsetLeft + parent.left,
        width: node.offsetWidth,
        height: node.offsetHeight
    };
};

exports.parseBackgrounds = function(backgroundImage) {
    var whitespace = ' \r\n\t',
        method, definition, prefix, prefix_i, block, results = [],
        mode = 0, numParen = 0, quote, args;
    var appendResult = function() {
        if(method) {
            if (definition.substr(0, 1) === '"') {
                definition = definition.substr(1, definition.length - 2);
            }
            if (definition) {
                args.push(definition);
            }
            if (method.substr(0, 1) === '-' && (prefix_i = method.indexOf('-', 1 ) + 1) > 0) {
                prefix = method.substr(0, prefix_i);
                method = method.substr(prefix_i);
            }
            results.push({
                prefix: prefix,
                method: method.toLowerCase(),
                value: block,
                args: args,
                image: null
            });
        }
        args = [];
        method = prefix = definition = block = '';
    };
    args = [];
    method = prefix = definition = block = '';
    backgroundImage.split("").forEach(function(c) {
        if (mode === 0 && whitespace.indexOf(c) > -1) {
            return;
        }
        switch(c) {
        case '"':
            if(!quote) {
                quote = c;
            } else if(quote === c) {
                quote = null;
            }
            break;
        case '(':
            if(quote) {
                break;
            } else if(mode === 0) {
                mode = 1;
                block += c;
                return;
            } else {
                numParen++;
            }
            break;
        case ')':
            if (quote) {
                break;
            } else if(mode === 1) {
                if(numParen === 0) {
                    mode = 0;
                    block += c;
                    appendResult();
                    return;
                } else {
                    numParen--;
                }
            }
            break;

        case ',':
            if (quote) {
                break;
            } else if(mode === 0) {
                appendResult();
                return;
            } else if (mode === 1) {
                if (numParen === 0 && !method.match(/^url$/i)) {
                    args.push(definition);
                    definition = '';
                    block += c;
                    return;
                }
            }
            break;
        }

        block += c;
        if (mode === 0) {
            method += c;
        } else {
            definition += c;
        }
    });

    appendResult();
    return results;
};

},{}],27:[function(_dereq_,module,exports){
var GradientContainer = _dereq_('./gradientcontainer');

function WebkitGradientContainer(imageData) {
    GradientContainer.apply(this, arguments);
    this.type = imageData.args[0] === "linear" ? GradientContainer.TYPES.LINEAR : GradientContainer.TYPES.RADIAL;
}

WebkitGradientContainer.prototype = Object.create(GradientContainer.prototype);

module.exports = WebkitGradientContainer;

},{"./gradientcontainer":9}],28:[function(_dereq_,module,exports){
function XHR(url) {
    return new Promise(function(resolve, reject) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url);

        xhr.onload = function() {
            if (xhr.status === 200) {
                resolve(xhr.responseText);
            } else {
                reject(new Error(xhr.statusText));
            }
        };

        xhr.onerror = function() {
            reject(new Error("Network Error"));
        };

        xhr.send();
    });
}

module.exports = XHR;

},{}]},{},[4])(4)
});
        </script>
        <script>
//      	var getPixelRatio = function(context) {
//      		var backingStore = context.webkitBackingStorePixelRatio || context.backingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || 1;
//      		return (window.devicePixelRatio || 1) / backingStore;
//      	};
//      	var canvas = document.querySelector('#canvas');
//      	var ctx = canvas.getContext('2d');
//      	var ratio = getPixelRatio(ctx);
//      	canvas.width = document.body.clientWidth*ratio;
//      	canvas.width = document.body.clientHeight*ratio;
//      	ctx.scale(ratio,ratio);
//      	html2canvas(document.body,{
//      		canvas:canvas,
//      		onrendered:function(canvas) {
//      			canvas.style.width = document.body.clientWidth + 'px';
//      			canvas.style.width = document.body.clientHeight + 'px';
//      			var dataUrl = canvas.toDataURL();
//      			var newImg = document.createElement("img");
//      			newImg.id = 'topic';
//      			newImg.src = dataUrl;
//      			document.body.appendChild(newImg);
//      		}
//      	})

			
			
			var shareContent = document.getElementById("shareContent");//需要截图的包裹的（原生的）DOM 对象
			var width = shareContent.offsetWidth; //获取dom 宽度
			var height = shareContent.offsetHeight; //获取dom 高度
			var canvas = document.createElement("canvas"); //创建一个canvas节点
			var scale = 3; //定义任意放大倍数 支持小数
			canvas.width = width * scale; //定义canvas 宽度 * 缩放
			canvas.height = height * scale; //定义canvas高度 *缩放
			canvas.getContext("2d").scale(scale,scale); //获取context,设置scale 
			var opts = {
//				allowTaint:false,
			    scale:scale, // 添加的scale 参数
			    canvas:canvas, //自定义 canvas
			    logging: true, //日志开关
			    width:width, //dom 原始宽度
			    height:height //dom 原始高度
			};
			
			html2canvas(shareContent, opts).then(function (canvas) {
			    //如果想要生成图片 引入canvas2Image.js 下载地址：
			    //https://github.com/hongru/canvas2image/blob/master/canvas2image.js
//			    var img = Canvas2Image.convertToImage(canvas, canvas.width, canvas.height);
				var url = canvas.toDataURL();//图片地址
			    $('.man').attr('src',url);
			});
			
			
        </script>
	</body>
	

</html>